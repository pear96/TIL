# CPU 스케줄링

> 운영체제의 역할 중 메모리 관리에서 **CPU 이용률을 최대화 하는 것**은 다중 프로세서 운영체제 설계의 핵심이다.

- CPU가 유휴 상태가 될 때마다, OS는 Ready Queue에 있는 프로세스 중 하나를 **선택**해서 실행해야한다.
  - Ready Queue에는 PCB들이 들어있다.
- **어떤 프로세스를 선택하느냐** = CPU 스케쥴러가 하는 일!
- CPU 스케줄링은 다음의 네 가지 상황에서 발생할 수 있다.
  - 프로세스가 Running -> Blocked (입출력 요청하는 시스템 콜)
  - 프로세스가 Running -> Ready (할당 시간 만료)
  - 프로세스가 Blocked -> Ready(입출력 완료 후 인터럽트)
  - 프로세스 종료



### 프로세스의 상태

<img src="https://user-images.githubusercontent.com/13609011/91695344-f2dfae80-eba8-11ea-9a9b-702192316170.jpeg" alt="download (5)" style="zoom:50%;" />

- 승인(Admitted) = 프로세스 생성이 가능하여 승인
- 스케줄러 디스패치(Scheduler Dispatch) : 준비 상태에 있는 프로세스 중 하나를 선택, 실행
- 인터럽트(Interrupt) : 예외, 입출력, 이벤트 등이 발생하여 **현재 실행중인 프로세스를 준비 상태로 바꾸고,** 해당 작업을 먼저 처리
- 입출력 또는 이벤트 대기(I/O or Event Wait) : 실행 중인 프로세스가 입출력이나 이벤트를 처리해야 하는 경우, 입출력 or 이벤트가 모두 끝날 때 까지 대기 상태로 만드는 것
- 입출력 또는 이벤트 완료(I/O or Event Completion) : 입출력 or 이벤트가 끝난 프로세스를 준비 상태로 전환하여 다시 스케줄러에 의해 선택될 수 있도록 만드는 것.

> 즉, 스케줄러는 "Ready" 상태의 프로세스만 실행(Dispatch) 시킬 수 있다.

### 프로세스 스케줄러 종류

- Job Scheduler = 프로그램이 저장되어있는 디스크에서 메모리로 프로세스 스케줄링
- CPU Scheduler = CPU와 메모리 사이의 스케줄링
- Swapper = 메모리에서 디스크로 프로세스 스케줄링 



## CPU 스케줄링의 종류

### 비선점(non preemptive)

> 프로세스 스스로 종료 or I/O 이벤트가 있을 때 까진 실행이 보장된다.

1. FCFS(First Come, Fist Served)
   - 큐에 도착한 순서대로 CPU를 할당
   - Convoy effect : 실행시간이 짧은게 뒤로 가면 평균 대기 시간이 길어진다.
2. SJF(Shortest Job First)
   - 수행시간이 짧은 것 부터 실행
   - starvation : 수행시간이 긴 프로세스는 거의 영원히 CPU를 할당 받을 수 없다.
   - FCFS 보다 평균 대기 시간 감소
3. HRN(Hightest Response-ratio Next)
   - 우선순위를 계산하여 SJF 의 단점인 불평등 보완
   - 우선순위 = (대기시간 + 실행시간) / 실행시간





### 선점(preemptive)

> 프로세스로부터 CPU를 강제로 회수한다.

1. Shortest Remaining Time First
   - 수행시간이 더 짧은 프로세스가 Ready Queue에 들어오면, 그 프로세스부터 수행
   - 현재 수행 중인 프로세스의 남은 수행시간보다 더 짧은 프로세스가 들어오면 CPU를 뺏김
   - starvation = 새로운 프로세스가 들어올 때마다 스케줄링을 다시하기 때문에 CPU 사용시간 측정 불가
2. Priority Scheduling
   - 우선순위대로 처리
   - starvation = 우선순위가 낮으면 무기한 대기해야한다. `Aging`을 통해 너무 오래 기다렸으면 우선순위를 높여준다.
   - 비선점형은 더 높은 우선순위가 들어오면 Ready Queue의 Head에 넣는다.
   - 선점형은 실행중인 프로세스를 멈추고 CPU를 선점한다.
3. Round Robin
   - 정해진 시간(`time quantam`)만큼 CPU를 할당할 수 있고, 끝나면 다시 대기해야됨
   - 할당시간이 크면 FCFS가 되고, 작으면 Context Switching이 잦아져 오버헤드 증가
4. 다단계 큐(Multilevel-Queue)
   - 작업들을 여러 종류의 그룹(할당 시간이 다름)으로 나누어 여러개의 큐를 사용



## CPU 스케줄링 비교 기준

- CPU 이용률 = 어느 기간 / 특정 SNAPSHOT에서 CPU 이용률
- 처리량 = 단위 시간당 완료된 프로세스이 개수
- 총 처리시간 = 프로세스 제출 시간 ~ 처리 완료 시간
- 대기시간 = 준비 큐에서 프로세스가 대기한 시간
- 응답시간 = 하나의 요청을 보내고 응답이 올 때 까지의 시간



# 데드락(DeadLock, 교착상태)

> 두개 이상의 프로세스/스레드가 서로 자원을 얻지 못해서 다음 처리를 하지 못하는 상태
>
> 무한히 다음 자원을 기다린다.
>
> 한정된 자원을 여러 곳에서 사용하려고 할 때 발생

![img](https://t1.daumcdn.net/cfile/tistory/243E89355714C26E28)

- 프로세스1은 자원2를 원하고, 프로세스 2는 자원1을 원하지만 둘 다 Lock이 걸려있어 아무것도 할 수 없음(서로 경쟁)
- 현재 서로 원하는 자원이 상대방에게 할당되어 있어 **무한정 wait 상태에 빠짐**
  - 멀티 프로그래밍 환경에서는 한정된 자원을 얻기 위해 서로 경쟁한다.
  - 한 프로세스가 자원을 요청했을 때 사용할 수 없다면 대기 상태로 전환된다.
  - 이후 실행 상태로 변경될 수 없을 때 **교착 상태**가 발생





## DeadLock 발생 조건 4가지

하나라도 성립하지 않는다면 해결가능하다.



### 1. 상호배제(Mutual Exclusion)

​	자원은 한번에 **한 프로세스**만 사용할 수 있다.

### 2. 점유 대기(Hold and Wait)

​	최소한 하나의 자원을 점유하고 있으면서, 동시에 다른 프로세스에 할당되어있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 존재

### 3. 비선점

​	다른 프로세스에 할당된 자원은 끝날 때 까지 **강제로 뺏을 수 없음**

### 4. 순환 대기

​	프로세스의 집합에서 **순환 형태**로 자원을 대기해야함

​	프로세스 P0, P1, ... Pn이 있을 때

​		P0은 P1이 가진 자원을 기다림

​		P1은 P2가 가진 자원을 기다림

​		Pn-1은 Pn이 가진 자원을 기다림

​		Pn은 P0이 가진 자원을 기다림



## DeadLock 해결 방법

### DeadLock Prevention

> 교착 상태 발생 조건 중 하나를 제거하면서 해결한다.

- 여러 프로세스가 공유 자원 사용(상호 배제 부정)
- 프로세스 실행 전 모든 자원 할당(점유 대기 부정)
- 점유 중인 자원을 다른 프로세스가 요구하면 반납(비선점 부정)
- 자원에 고유번호 할당 후 순서대로 요구(순환 대기 부정)

### DeadLock Avoidance

> 교착 상태 발생시 피해가는 방법

- Banker's Algorithm
  - 프로세스가 자원을 요구할때, 할당 후에도 안정 상태면 주고, 아니라면 다른 프로세스들이 자원을 해지할 때까지 대기



### DeadLock Detection & Recovery

> 교착 상태가 되도록 허용한 후 회복

- 자원 할당 그래프를 통해 교착 상태 탐지, 매번 탐지하면 오버헤드 발생

- 교착 상태를 일으킨 프로세스를 종료하거나, 할당된 자원을 해제한다.
  - 교착 상태의 프로세스 모두 중지 or 하나씩 중지해보기
  - 교착 상태의 프로세스가 점유하는 자원을 선점해 다른 프로세스에 할당



대부분의 범용 OS는 데드락이 발생하면 응답없음을 띄워 사람이 직접 종료하게 만든다.





# 경쟁상태(Race Condition)

> 공유 자원에 대해 여러 프로세스가 동시에 접근할 때, 순서에 따라 결과값에 영향을 줄 수 있다. (= 일관성 파괴)



## 경쟁상태가 발생하는 경우

### 1. 커널 작업 중 인터럽트 발생

- 커널 모드에서 데이터를 작업하다 인터럽트가 발생했는데 같은 데이터를 조작하는 경우
- 커널 모드에서 작업하는 동안, 인터럽트를 disable시켜 해결. 



### 2. 프로세스가 시스템 콜로 커널 모드에 진입하여 작업 중 문맥 교환이 발생

- 프로세스 1이 커널모드에서 작업 하는 도중 시간이 초과되어 프로세스2가 CPU를 사용하는데 같은 데이터가 필요한 경우
- 프로세스가 커널모드에서 작업한다면 시간이 초과되어도 CPU 제어권 계속 가짐
- 사용자 모드로 돌아갔을 때 뺏어갈 수 있다.



### 3. 멀티 프로세서 환경에서 공유 메모리 내의 커널 데이터에 접근

- 2개의 CPU가 동시에 커널 내부의 공유 데이터 접근
- 멀티 프로세서는 인터럽트 disable로 안막아짐
- 해결 1 = 공유 데이터라도 커널 내부에 접근한다면 그 데이터를 lock/unlock 한다.
- 해결 2 = 한 번에 하나의 CPU만이 커널에 들어갈 수 있게 하는 방법





