# CPU 스케줄링

> 운영체제의 역할 중 메모리 관리에서 **CPU 이용률을 최대화 하는 것**은 다중 프로세서 운영체제 설계의 핵심이다.

- CPU가 유휴 상태가 될 때마다, OS는 Ready Queue에 있는 프로세스 중 하나를 **선택**해서 실행해야한다.
  - Ready Queue에는 PCB들이 들어있다.
- **어떤 프로세스를 선택하느냐** = CPU 스케쥴러가 하는 일!
- CPU 스케줄링은 다음의 네 가지 상황에서 발생할 수 있다.
  - 프로세스가 Running -> Blocked (입출력 요청하는 시스템 콜)
  - 프로세스가 Running -> Ready (할당 시간 만료)
  - 프로세스가 Blocked -> Ready(입출력 완료 후 인터럽트)
  - 프로세스 종료



### 프로세스의 상태

<img src="https://user-images.githubusercontent.com/13609011/91695344-f2dfae80-eba8-11ea-9a9b-702192316170.jpeg" alt="download (5)" style="zoom:50%;" />

- 승인(Admitted) = 프로세스 생성이 가능하여 승인
- 스케줄러 디스패치(Scheduler Dispatch) : 준비 상태에 있는 프로세스 중 하나를 선택, 실행
- 인터럽트(Interrupt) : 예외, 입출력, 이벤트 등이 발생하여 **현재 실행중인 프로세스를 준비 상태로 바꾸고,** 해당 작업을 먼저 처리
- 입출력 또는 이벤트 대기(I/O or Event Wait) : 실행 중인 프로세스가 입출력이나 이벤트를 처리해야 하는 경우, 입출력 or 이벤트가 모두 끝날 때 까지 대기 상태로 만드는 것
- 입출력 또는 이벤트 완료(I/O or Event Completion) : 입출력 or 이벤트가 끝난 프로세스를 준비 상태로 전환하여 다시 스케줄러에 의해 선택될 수 있도록 만드는 것.

> 즉, 스케줄러는 "Ready" 상태의 프로세스만 실행(Dispatch) 시킬 수 있다.

### 프로세스 스케줄러 종류

- Job Scheduler = 프로그램이 저장되어있는 디스크에서 메모리로 프로세스 스케줄링
- CPU Scheduler = CPU와 메모리 사이의 스케줄링
- Swapper = 메모리에서 디스크로 프로세스 스케줄링 



## CPU 스케줄링의 종류

### 비선점(non preemptive)

> 프로세스 스스로 종료 or I/O 이벤트가 있을 때 까진 실행이 보장된다.

1. FCFS(First Come, Fist Served)
   - 큐에 도착한 순서대로 CPU를 할당
   - Convoy effect : 실행시간이 짧은게 뒤로 가면 평균 대기 시간이 길어진다.
2. SJF(Shortest Job First)
   - 수행시간이 짧은 것 부터 실행
   - starvation : 수행시간이 긴 프로세스는 거의 영원히 CPU를 할당 받을 수 없다.
   - FCFS 보다 평균 대기 시간 감소
3. HRN(Hightest Response-ratio Next)
   - 우선순위를 계산하여 SJF 의 단점인 불평등 보완
   - 우선순위 = (대기시간 + 실행시간) / 실행시간





### 선점(preemptive)

> 프로세스로부터 CPU를 강제로 회수한다.

1. Shortest Remaining Time First
   - 수행시간이 더 짧은 프로세스가 Ready Queue에 들어오면, 그 프로세스부터 수행
   - 현재 수행 중인 프로세스의 남은 수행시간보다 더 짧은 프로세스가 들어오면 CPU를 뺏김
   - starvation = 새로운 프로세스가 들어올 때마다 스케줄링을 다시하기 때문에 CPU 사용시간 측정 불가
2. Priority Scheduling
   - 우선순위대로 처리
   - starvation = 우선순위가 낮으면 무기한 대기해야한다. `Aging`을 통해 너무 오래 기다렸으면 우선순위를 높여준다.
   - 비선점형은 더 높은 우선순위가 들어오면 Ready Queue의 Head에 넣는다.
   - 선점형은 실행중인 프로세스를 멈추고 CPU를 선점한다.
3. Round Robin
   - 정해진 시간(`time quantam`)만큼 CPU를 할당할 수 있고, 끝나면 다시 대기해야됨
   - 할당시간이 크면 FCFS가 되고, 작으면 Context Switching이 잦아져 오버헤드 증가
4. 다단계 큐(Multilevel-Queue)
   - 작업들을 여러 종류의 그룹(할당 시간이 다름)으로 나누어 여러개의 큐를 사용



## CPU 스케줄링 비교 기준

- CPU 이용률 = 어느 기간 / 특정 SNAPSHOT에서 CPU 이용률
- 처리량 = 단위 시간당 완료된 프로세스이 개수
- 총 처리시간 = 프로세스 제출 시간 ~ 처리 완료 시간
- 대기시간 = 준비 큐에서 프로세스가 대기한 시간
- 응답시간 = 하나의 요청을 보내고 응답이 올 때 까지의 시간



# 데드락(DeadLock, 교착상태)

> 두개 이상의 프로세스/스레드가 서로 자원을 얻지 못해서 다음 처리를 하지 못하는 상태
>
> 무한히 다음 자원을 기다린다.
>
> 한정된 자원을 여러 곳에서 사용하려고 할 때 발생

![img](https://t1.daumcdn.net/cfile/tistory/243E89355714C26E28)

- 프로세스1은 자원2를 원하고, 프로세스 2는 자원1을 원하지만 둘 다 Lock이 걸려있어 아무것도 할 수 없음(서로 경쟁)
- 현재 서로 원하는 자원이 상대방에게 할당되어 있어 **무한정 wait 상태에 빠짐**
  - 멀티 프로그래밍 환경에서는 한정된 자원을 얻기 위해 서로 경쟁한다.
  - 한 프로세스가 자원을 요청했을 때 사용할 수 없다면 대기 상태로 전환된다.
  - 이후 실행 상태로 변경될 수 없을 때 **교착 상태**가 발생





## DeadLock 발생 조건 4가지

하나라도 성립하지 않는다면 해결가능하다.



### 1. 상호배제(Mutual Exclusion)

​	자원은 한번에 **한 프로세스**만 사용할 수 있다.

### 2. 점유 대기(Hold and Wait)

​	최소한 하나의 자원을 점유하고 있으면서, 동시에 다른 프로세스에 할당되어있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 존재

### 3. 비선점

​	다른 프로세스에 할당된 자원은 끝날 때 까지 **강제로 뺏을 수 없음**

### 4. 순환 대기

​	프로세스의 집합에서 **순환 형태**로 자원을 대기해야함

​	프로세스 P0, P1, ... Pn이 있을 때

​		P0은 P1이 가진 자원을 기다림

​		P1은 P2가 가진 자원을 기다림

​		Pn-1은 Pn이 가진 자원을 기다림

​		Pn은 P0이 가진 자원을 기다림



## DeadLock 해결 방법

### DeadLock Prevention

> 교착 상태 발생 조건 중 하나를 제거하면서 해결한다.

- 여러 프로세스가 공유 자원 사용(상호 배제 부정)
- 프로세스 실행 전 모든 자원 할당(점유 대기 부정)
- 점유 중인 자원을 다른 프로세스가 요구하면 반납(비선점 부정)
- 자원에 고유번호 할당 후 순서대로 요구(순환 대기 부정)

### DeadLock Avoidance

> 교착 상태 발생시 피해가는 방법

- Banker's Algorithm
  - 프로세스가 자원을 요구할때, 할당 후에도 안정 상태면 주고, 아니라면 다른 프로세스들이 자원을 해지할 때까지 대기



### DeadLock Detection & Recovery

> 교착 상태가 되도록 허용한 후 회복

- 자원 할당 그래프를 통해 교착 상태 탐지, 매번 탐지하면 오버헤드 발생

- 교착 상태를 일으킨 프로세스를 종료하거나, 할당된 자원을 해제한다.
  - 교착 상태의 프로세스 모두 중지 or 하나씩 중지해보기
  - 교착 상태의 프로세스가 점유하는 자원을 선점해 다른 프로세스에 할당



대부분의 범용 OS는 데드락이 발생하면 응답없음을 띄워 사람이 직접 종료하게 만든다.





# 경쟁상태(Race Condition)

> 공유 자원에 대해 여러 프로세스가 동시에 접근할 때, 순서에 따라 결과값에 영향을 줄 수 있다. (= 일관성 파괴)



## 경쟁상태가 발생하는 경우

### 1. 커널 작업 중 인터럽트 발생

- 커널 모드에서 데이터를 작업하다 인터럽트가 발생했는데 같은 데이터를 조작하는 경우
- 커널 모드에서 작업하는 동안, 인터럽트를 disable시켜 해결. 



### 2. 프로세스가 시스템 콜로 커널 모드에 진입하여 작업 중 문맥 교환이 발생

- 프로세스 1이 커널모드에서 작업 하는 도중 시간이 초과되어 프로세스2가 CPU를 사용하는데 같은 데이터가 필요한 경우
- 프로세스가 커널모드에서 작업한다면 시간이 초과되어도 CPU 제어권 계속 가짐
- 사용자 모드로 돌아갔을 때 뺏어갈 수 있다.



### 3. 멀티 프로세서 환경에서 공유 메모리 내의 커널 데이터에 접근

- 2개의 CPU가 동시에 커널 내부의 공유 데이터 접근
- 멀티 프로세서는 인터럽트 disable로 안막아짐
- 해결 1 = 공유 데이터라도 커널 내부에 접근한다면 그 데이터를 lock/unlock 한다.
- 해결 2 = 한 번에 하나의 CPU만이 커널에 들어갈 수 있게 하는 방법





# 세마포어 & 뮤텍스

- 경쟁 상태를 예방하기 위한 방법이다.

- 임계 구역(Critical Section)문제를 해결하기 위한 조건
  - 상호 배제 = 한 프로세스가 이미 Critical Section에서 실행중이라면, 다른 프로세스는 접근 불가
  - 진행 = Critical Section에서 실행중인 프로세스가 없고, 별도의 동작이 없는 프로세스들만 참여할 수 있음
  - 한정된 대기 = Critical Section에 접근했던 프로세스라면, 횟수 제한을 두어서 다른 프로세스도 접근할 수 있도록 해야한다.



|        | Semaphore                                                    | Mutex                                                        |
| ------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
|        | ![img](https://blog.kakaocdn.net/dn/cgvF68/btqDyMXcTWu/zhuMLl9YWBrhRkv6xkEm11/img.png) | ![img](https://blog.kakaocdn.net/dn/KK4GG/btqDyMXcTVK/dMLkVA1QUmN3khbdFuxoF1/img.png) |
| 역할   | 공유된 자원의 데이터를 **여러 프로세스**가 접근하는 것을 막음 | 공유된 자원의 데이터를 **여러 스레드**가 접근하는 것을 막음  |
| 차이점 | 하나의 스레드만 들어가게 할 수도 있고 여러 개의 스레드가 들어가게 할 수 있다. = Mutex의 단점 보완 | 이진 세마포어로, 한번에 하나의 스레드만 접근할 수 있다.      |
| 함수   | P() : 임계 구역 들어가기 전<br>S() : 임계 구역에서 나올 때   | lock() : 임계 구역에 들어갈 권한을 얻는다.<br>unlock() :임계 구역을 모두 사용했음을 알린다. |
| 방식   | **가용한 개수를 가진 자원** 에 대한 접근 제어용으로 사용되며, 세마포는 그 가용한 **자원의 개수** 로 초기화 된다. 자원을 사용하면 세마포가 감소, 방출하면 세마포가 증가 한다. | MUTEX 라고도 부르며, 상호배제의 (Mutual Exclusion)의 머릿글자를 따서 만들어졌다. 이름 그대로 0 과 1 사이의 값만 가능하며, 다중 프로세스들 사이의 Critical Section 문제를 해결하기 위해 사용한다. |

```
( 차이점들!! )
<Mutex vs Semaphore>
1) Semaphore는 Mutex가 될 수 있지만 Mutex는 Semaphore가 될 수 없습니다.
(Mutex 는 상태가 0, 1 두 개 뿐인 binary Semaphore)
2) Semaphore는 소유할 수 없는 반면, Mutex는 소유가 가능하며 소유주가 이에 대한 책임을 집니다. (Mutex 의 경우 상태가 두개 뿐인 lock 이므로 lock 을 ‘가질’ 수 있습니다.)
3) Mutex의 경우 Mutex를 소유하고 있는 쓰레드가 이 Mutex를 해제할 수 있습니다. 하지만 Semaphore의 경우 이러한 Semaphore를 소유하지 않는 쓰레드가 Semaphore를 해제할 수 있습니다.
4) Semaphore는 시스템 범위에 걸쳐있고 파일시스템상의 파일 형태로 존재합니다. 반면 Mutex는 프로세스 범위를 가지며 프로세스가 종료될 때 자동으로 Clean up된다.

★★★ 가장 큰 차이점은 관리하는 동기화 대상의 갯수입니다. Mutex는 동기화 대상이 오직 하나뿐일 때, Semaphore는 동기화 대상이 하나 이상일 때 사용합니다.
```

출처: https://jwprogramming.tistory.com/13?category=680235 [개발자를 꿈꾸는 프로그래머:티스토리]





### 세마포어 예시

> 최초 S = 1이고, 해당 구역에 접근해야하는 프로세스가 A, B 존재

1. 먼저 도착한 A가 P(S)를 실행하여 임계구역에 진입. S = 0
2. 그 뒤 도착한 B는 S = 0 이라 P(S)를 실행했지만 대기
3. A가 임계구역에서 수행을 마치고 V(S)를 실행. 다시 S = 1
4. B는 이제 임계구역에 들어갈 수 있음.





### 임계구역(Critical Section)

- 각 프로세스에서 공유 데이터를 접근하는 프로그램 **코드**부분
- 공유 데이터를 여러 프로세스가 동시에 접근할 때 잘못된 결과를 만들 수 있기 때문에, 한 프로세스가 임계 구역을 수행할 때는 다른 프로세스가 접근하지 못하도록 해야 한다.



### 뮤텍스 알고리즘

#### Dekker 

- flag(어느 프로세스가 임계구역에 접근할 것인지) 와 turn(누가 임계구역에 들어갈 차례인지) 변수를 통해 임계 구역에 들어갈 프로세스/ 스레드를 정함

```
while(true) {
	flag[i] = true;
	while(flag[j]) {
		if(turn==j) {
			flag[i] = false; // i는 못 들어간다.
			while (turn==j);
			flag[i] = truel // j의 차례가 넘어가고 나서야 다시 진입 시도
		}
	}
}

//--- 임계 구역
turn = j; // 임계 구역 사용 끝나면 turn을 넘김
flag[i] = false; // flag를 false로 바꿔 i의 임계 구역 사용 완료
```



### Peterson

- 데커와 유사하지만, 상대방 프로세스/스레드에게 진입 기회를 **양보**하는 것에 차이 존재

```
while(true) {
	flag[i] = true // i가 임계 구역에 들어가려고 했으나
	turn = j; // 다른 프로세스에게 진입 기회 양보
	while(flag[j] && turn == j) {
		// 다른 프로세스가 진입 시도하면 대기
	}
}

//---- 임계구역
flag[i] = false; // i는 임계구역 사용 완료
```





### Bakery

- 번호표의 숫자에 따라 여러 프로세스/ 스레드에 대한 처리가 가능함

```
while(true) {
	isReady[i] = true; // i 번호표 받을 준비 완료
	number[i] = max(number[0~n-1]) + 1 // 현재 앞에 번호 부여받은 프로세스들보다 가장 늦어야함
	isReady[i] = false; // i 번호표 받음
	
	for(j=0; j < n; j++) {
		// 모든 프로세스의 번호표를 비교한다.
		while(isReady[j]); // 비교 프로세스가 번호표를 받을 때 까지 대기
		while(number[j] && number[j] < number[i] && j <i) {
			// j가 번호표를 가지고 있어야함
		}
	}
}

// ---- 임계 구역
number[i] = 0; //임계구역 사용 완료
```





# 질문

```
💡 멀티 쓰레드 환경에서의 주의사항을 설명해주세요.
다수의 쓰레드가 공유 데이터에 동시에 접근하는 경우에 상호배제 또는 동기화 기법을 통해 동시성 문제 또는 교착 상태가 발생하지 않도록 주의해야 합니다.

💡 데드락에 대해 설명해주세요.
둘 이상의 프로세스들이 자원을 점유한 상태에서 서로 다른 프로세스가 점유하고 있는 자원을 요구하며 무한정 기다리는 상황을 말합니다.
예를 들어, 자원 A를 가진 프로세스 P1과 자원 B를 가진 프로세스 P2가 있을 때, P1은 B를 필요로 하고 P2는 A를 필요로 한다면 두 프로세스는 서로 자원을 얻기 위해 무한정 기다리게 됩니다.

데드락의 4가지 조건

비선점 (Nonpreemptive) : 다른 프로세스의 자원을 뺏을 수 없음.
순환 대기 (Circular wait) : 두 개 이상의 프로세스가 자원 접근을 기다릴 때, 관계가 순환적 구조.
점유 대기 (Hold & Wait) : 공유 자원에 대한 접근 권한을 가진 채로 다른 자원에 대한 접근 권한을 요구.
상호 배제(Mutual Exclusion) : 한 번에 한 프로세스만 공유 자원에 접근 가능하며, 접근 권한이 제한적일 경우.




💡 콘보이 현상(convoy effect)이란 무엇이고, 콘보이 현상이 발생될 수 있는 CPU 스케줄러 알고리즘은 무엇인지 설명해주세요.
콘보이 현상이란 작업 시간이 긴 프로세스가 먼저 큐에 도착해서 다른 프로세스의 실행 시간이 전부 늦춰져 효율성을 떨어뜨리는 현상을 말합니다.
FCFS(First-Come First Served) 스케줄링은 비선점형으로, 순차적으로 먼저 큐에 들어온 작업부터 실행하므로 콘보이 현상이 발생할 수 있습니다.

💡 선점형 스케줄링과 비선점형 스케줄링의 차이를 설명해주세요.
선점형은 하나의 프로세스가 다른 프로세스 대신에 CPU를 차지할 수 있음을 말하고,
비선점형은 하나의 프로세스가 끝나지 않으면 다른 프로세스는 CPU를 사용할 수 없음을 말합니다.

💡 Critical Section(임계영역)에 대해 설명해주세요.
임계 영역이란 프로세스간에 공유자원을 접근하는데 있어 문제가 발생하지 않도록 한번에 하나의 프로세스만 이용하게끔 보장해줘야 하는 영역을 말합니다.
임계 영역 문제를 해결하기 위해서는 아래의 3가지 조건을 충족해야 합니다.

상호 배제(Mutual exclution) - 하나의 프로세스가 임계 영역에 들어가 있다면 다른 프로세스는 들어갈 수 없어야 한다.
진행(Progress) - 임계 영역에 들어간 프로세스가 없는 상태에서 들어가려 하는 프로세스가 여러 개라면 어느 것이 들어갈지 결정 해주어야 한다.
한정 대기(Bounded waiting) - 다른 프로세스의 기아를 방지하기 위해, 한 번 임계 구역에 들어간 프로세스는 다음 번 임계 영역에 들어갈 때 제한을 두어야 한다.


💡 뮤텍스(Mutex)와 세마포어(Semaphore)의 차이에 대해 설명해주세요.
뮤텍스는 Lock을 사용해 하나의 프로세스나 쓰레드를 단독으로 실행하게 합니다. 
반면에 세마포어는 공유자원에 세마포어 변수만큼의 프로세스(또는 쓰레드)가 접근할 수 있습니다.
세마포어의 변수 → 공유자원의 개수를 나타내는 변수
 
현재 수행중인 프로세스가 아닌 다른 프로세스가 세마포어를 해제할 수 있습니다.
하지만 뮤텍스는 락(lock)을 획득한 프로세스가 반드시 그 락을 해제해야 합니다.
 
0과 1의 값만 갖는 세마포어 → 이진 세마포어(binary semaphore) (= 뮤텍스)
도메인 제한이 없는 세마포어(0,1 뿐만아니라 2,3,4 등의 값들 또한 가질 수 있는) → 카운팅 세마포어(counting semaphore)

```

출처: https://dev-coco.tistory.com/162 [슬기로운 개발생활:티스토리]





## 참고

[병행 프로세스 동기화](https://github.com/qkraudghgh/coding-interview/blob/master/OS/Synchronization.md)

[프로세스 동기화](https://github.com/pear96/cs-zz/blob/main/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/06%20%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%20%EB%8F%99%EA%B8%B0%ED%99%94.md)