# 운영체제란?

> 운영체제란 사용자와 컴퓨터를 이어주는 다리 (=인터페이스)
>
> 사용자가 편리하고 효율적으로 컴퓨터를 사용하게 해주는 **시스템 소프트웨어**

## 운영체제 역할

### 1\. 프로세스 관리

프로세서(CPU)를 관리하는 것과 일맥상통. 프로세서를 점유할 프로세스를 할당하고, 프로세스간 자원 접근, 통신을 관리한다.

### 2\. 저장장치 관리

메인 메모리와 하드디스크를 관리한다.

-   메인 메모리는 프로세스에 할당하는 것이고, 하드디스크는 파일 형식의 데이터를 저장한다. 이 파일 시스템을 OS에서 관리한다. USB 포맷할 때 FAT, NTFS등을 바꿀 수 있는데 그러면 파일 하나당 최대 크기가 4GB에서 늘어나기도 한다.

### 3\. 네트워킹

네트워크는 그냥 되는게 아니라, OS에서 네트워크 프로토콜을 지원해야한다. 현재 상용 OS들은 네트워크 프로토콜을 지원한다.

### 4\. 사용자 관리

Window, Ubunt에도 사용자가 있다. 사용자 별로 파일 접근 권한을 나누는 것도 OS가 하는 일이다. Window는 계정이 바뀌면 Users에도 생기고 바탕화면도 따로 사용한다. Ubuntu는 더 사용자 권한에 민감한 것 같다. root 계정이 권한을 가진 파일은 하위 사용자가 사용할 수 없다.

### 5\. 디바이스 드라이버

키보드, 마우스 입력, 스피커, 등등 많은 하드웨어와 시스템 자원을 관리해야한다. OS 안에 하드웨어를 `추상화` 해주는 계층이 필요하다. 이 계층이 바로 **디바이스 드라이버**이다. (그래픽 드라이버, 와콤 타블렛 드라이버, 사운드 드라이버, 로지텍 등등 디바이스와 관련된 드라이버를 설치한 경험이 무조건 있을 것이다.)

# 프로세스와 스레드

|                 프로세스                 |                 스레드                  |
| :--------------------------------------: | :-------------------------------------: |
| 프로그램을 `메모리 상`에서 실행중인 작업 | 프로세스 안에서 실행되는 여러 흐름 단위 |
|  자신만의 고유한 공간, 자원을 할당받음   | 스레드끼리 공간, 자원을 공유하면서 사용 |

-   프로세스 안에 여러개의 스레드가 있구나. 스레드는 프로세스의 자원을 사용한다.
-   기본적으로 프로세스마다 최소 1개의 스레드를 소유한다.
-   프로세스 끼리는 자원을 공유하지 않으므로 IPC(Inter-Process Communication)를 통해 통신해야한다.

![img](https://camo.githubusercontent.com/3dc4ad61f03160c310a855a4bd68a9f2a2c9a4c7/68747470733a2f2f74312e6461756d63646e2e6e65742f6366696c652f746973746f72792f393938383931343635433637433330363036)

-   코드 - 프로그램 명령
-   데이터 - 전역변수, 정적변수, 배열 등
-   Heap - 동적 할당시 사용 (?)
-   Stack - 지역변수, 매개변수, 리턴 값 등 임시 메모리 영역 (스레드는 Stack만 따로 할당받음)

|   구분    |                     멀티 프로세스                     | 멀티 스레드                                                  |
| :-------: | :---------------------------------------------------: | ------------------------------------------------------------ |
|   정의    | 하나의 프로그램을 여러개의 프로세스가 병렬적으로 작업 | 하나의 프로그램에서 여러 스레드를 사용하며 각 스레드가 하나의 작업 처리 |
|   장점    |                      메모리 안전                      | 공유하는 만큼 시간, 자원을 아낌.                             |
|   단점    | 메모리를 각각 사용하여 작업량이 많으면 오버헤드 발생  | 하나의 스레드가 잘못하면 모든 스레드가 작동 불능할 수 있다.(공유 메모리) |
| 관련 정보 |                   Context Switching                   | Critical Section                                             |

-   Context Switching = 하나의 프로세스가 CPU를 사용 중인 상태에서 다른 프로세스가 CPU를 사용하도록 하기 위해, 이전의 프로세스 상태를 보관하고 새로운 프로세스의 상태를 적재하는 작업
-   Critical Section = 하나의 스레드가 공유하는 값을 바꾸려는 순간에 다른 스레드가 그 값을 읽으려 할때 문제가 발생하는걸 해결하기 위한 동기화 (마치 DB 같구만)



# 프로세스의 주소 공간

프로그램이 실행되면 프로세스가 생기고, 메모리에 프로세스 주소 공간이 할당된다.

> 프로세스 주소 공간 = 코드 + 데이터 + 스택

![img](https://camo.githubusercontent.com/3dc4ad61f03160c310a855a4bd68a9f2a2c9a4c7/68747470733a2f2f74312e6461756d63646e2e6e65742f6366696c652f746973746f72792f393938383931343635433637433330363036)

-   코드 = 소스 코드
-   데이터 = 전역 변수
-   스택 = 지역변수, 함수

=> 구역을 나눈 이유는, 최대한 데이터를 공유하여 메모리를 아끼기 위함이다.

데이터와 스택이 나뉜 이유는, 스택 구조의 특성과 전역변수의 활용성을 위함이다.

함수 A { 함수 B { 함수 C}} 의 경우 함수 C => B => A 순으로 결과가 나온다.

함수나 지역변수는 스택 형식. 전역변수는 따로 관리해주면 더 메모리를 아낄 수 있음.

---

추가 내용

[https://mangkyu.tistory.com/92](https://mangkyu.tistory.com/92)



# OS 2

## 인터럽트

프로그램을 실행하는 도중 **예기치 않은 상황**이 발생한 경우, 현재 실행 중인 작업을 즉시 중단하고, 발생된 상황에 대한 **우선 처리**가 필요함을 CPU에 알리는 것

> 발생 시기를 예측하기 힘든 경우에 컨트롤러가 가장 빠르게 대응할 수 있는 방법





- 내/외부 인터럽트 = CPU의 하드웨어 신호에 의해 발생 
  - 외부 = 입출력 장치, 타이밍 장치, 전원 등 외부적인 요인으로 발생
  - 내부 = Trap이라고 부르며, 잘못된 명령이나 데이터를 사용할 때 발생(0으로 나누기, 오버플로우, Exception..)
- 소프트웨어 인터럽트 = 명령어 수행에 의해 발생
  - `소프트웨어 이용 중에 다른 프로세스를 실행시키면 시분할 처리를 위해 자원 할당 동작이 수행된다.` 가 뭔 소린지??

### 인터럽트 발생 처리 과정

![img](https://mblogthumb-phinf.pstatic.net/20160310_124/scw0531_14575366291105WjS7_PNG/ERTRTETRE.png?type=w2)

1. 주 프로그램 실행 중
2. 인터럽트 발생
3. 현재 수행중인 주 프로그램 멈춤, 스택에 잠시 저장(다시 돌아오기 위함)
4. 인터럽트 서비스 루틴(만약 인터럽트가 없다면 어떤 일을 할 시기를 알기 위해 **계속 체크(=폴링)**해야한다.)
   - 폴링하는 시간에는 원래 하던 일에 집중할 수 없어 많은 기능을 제대로 수행하지 못한다.



### 우선순위 판별 방법 두가지

1. 폴링 방식 
   - 사용자가 명령어를 사용해 입력 핀의 값을 계속 읽어 변화를 알아낸다.
   - `인터럽트 요청 플래그를 차례로 비교하여 우선순위가 가장 높은 인터럽트 자원을 찾아 이에 맞는 인터럽트 서비스 루틴을 수행한다.`????
2. 인터럽트 방식
   - `MCU` 자체가 **하드웨어적으로 변화**를 체크하여 변화 시에만 일정한 동작을 하는 방식
   - `Daisy Chain`
   - `병렬 우선순위 부여`
   - 인터럽트 방식은 하드웨어로 지원을 받아야 하는 제약이 있지만, 폴링에 비해 신속하게 대응하는 것이 가능하다. 따라서 **실시간 대응**이 필요할 때는 필수적인 기능이다.





## 시스템 콜

> 프로세스 생성과 제어를 위함



- `fork()` = 새로운 프로세스를 생성할 때
  - 프로세스를 하나 더 생성하는데, 이때 생긴 프로세스는 **child**이며 fork 당한 프로세스(**parent**)와 동일한 복사본을 갖게된다. 이때 OS는 똑같은 2개의 프로그램이 동작한다고 생각하고 fork()가 return될 차례라고 생각한다. 동일한 프로세스 여러번 동작
  - child와 parent의 `fork()` 값이 다르다. 완전히 동일한 복사본은 아니다.

- `wait()` = child 프로세스가 종료될 때 까지 기다리는 작업
- `exec()` = child에서 parent와 다른 동작을 하고 싶을 때 사용



```
exec가 실행되면,

execvp( 실행 파일, 전달 인자 ) 함수는, code segment 영역에 실행 파일의 코드를 읽어와서 덮어 씌운다.

씌운 이후에는, heap, stack, 다른 메모리 영역이 초기화되고, OS는 그냥 실행한다. 즉, 새로운 Process를 생성하지 않고, 현재 프로그램에 wc라는 파일을 실행한다. 그로인해서, execvp() 이후의 부분은 실행되지 않는다.

이게 뭔 소리야?
```





## PCB & Context Switching

Process Management = CPU가 프로세스가 여러개일 때, CPU 스케줄링을 통해 관리하는 것을 말함

이때, CPU는 각 프로세스가 누군지 알아야 관리할 수 있으므로, 그 근거가 되는 것이 `Process Metadata`

이 메타데이터는 PCB(Process Control Block)에 저장된다. 한 PCB 안에는 한 프로세스의 정보

![img](https://t1.daumcdn.net/cfile/tistory/25673A5058F211C224)

### PCB가 필요한 이유

- CPU에서 프로세스 상태에 따라 교체작업이 이루어진다. **앞으로 다시 수행할 대기 중인 프로세스에 관한 저장 값이 PCB에 저장**

### PCB 관리 방법

- Linked List 방식
- 주소값으로 연결이 이루어져있는 연결 리스트라 삽입, 삭제 용이
- 프로세스가 생성되면 해당 PCB가 생성되고, 프로세스 완료시 제거된다.'



## Context Switching

> CPU가 이전의 프로세스 상태를 PCB에 보관하고, 또 다른 프로세스의 정보를 PCB에 읽어 레지스터에 적재하는 과정

- 인터럽트 발생
- CPU 사용 허가시간 모두 소모
- 입출력 대기



#### overhead

- CPU에 계속 프로세스를 수행시키기 위해 다른 프로세스를 실행시키고 Context Switching





## Inter Process Communication

- 프로세스는 독립적이기 때문에 프로세스끼리 영향 X
- 그렇기 때문에 프로세스끼리 통신해야할 경우, 커널이 제공하는 IPC가 필요하다.



> 커널 = 운영체제의 핵심적인 부분

### IPC 종류

1. 익명 PIPE
   - 하나의 프로세스는 데이터를 쓰기만 하고, 나머지는 읽기만 가능
   - 한쪽 방향으로만 통신 가능, 양쪽 방향 통신하려면 파이프 2개 필요
   - 매우 간단하지만 전이중 통신(양방향)을 만들려면 복잡해진다.
2. Named PIPE
   - 익명 파이프는 통신할 프로세스를 명확히 알아야하는 대신, Named 파이프는 전혀 모르는 상태의 프로세스들 사이 통신 가능
   - 부모 프로세스와 무관한 다른 프로세스도 통신 가능
   - 그러나 이 역시 동시 읽기/쓰기 불가능.
3. Message Queue
   - 데이터 흐름이 아니라 메모리 공간
   - 사용할 데이터에 번호를 붙이면서 여러 프로세스가 동시에 데이터를 쉽게 다룰 수 있음
4. 공유 메모리
   - 데이터 자체를 공유하도록 지원
   - 스레드처럼 메모리 영역을 공유해서 사용할 수 있도록 허용(커널이 해줌)
   - 중개자 없이 곧바로 메모리에 접근할 수 있어서 IPC 중 가장 빠르다!
5. 메모리 맵
   - 열린 파일을 메모리에 맵핑 시켜서 공유
   - 파일로 대용량 데이터를 공유해야할 때
6. 소켓
   - 네트워크 소켓 통신
   - 클라이언트와 서버가 소켓을 통해서 통신하는 구조로, 원격에서 프로세스 간 데이터를 공유할 때 사용한다.



`이러한 IPC 통신에서 프로세스 간 데이터를 동기화하고 보호하기 위해 세마포어와 뮤텍스를 사용한다. (공유된 자원에 한번에 하나의 프로세스만 접근시킬 때)` ????







# 질문

1.  프로세스와 스레드의 차이
2.  멀티 프로세스로 처리가 가능한걸 굳이 멀티 스레드로 하는 이유는?
3.  교착상태란 무엇이며, 4가지 조건은?
4.  교착상태 해결 방법 4가지