# Memory

> 프로그램을 실행하기 위해 필요한 정보들은 메모리에 저장된다. 작업의 처리 대상 또는 결과를 저장하는 공간



## Main Memory

- 프로세스가 실행되려면 프로그램이 메모리에 올라와야한다.
- 주소가 할당된 일련의 바이트들로 구성

- CPU는 레지스터가 지시하는대로 메모리에 접근하여 다음에 수행할 명령어를 가져옴
- 명령어 수행 시 메모리에 필요한 데이터가 없으면 해당 데이터를 우선 가져와야 함(MMU)



### Memory Management Unit

- 논리 주소를 물리 주소로 변환
- 메모리 보호, 캐시 관리 등 CPU가 메모리에 접근하는 것을 총 관리해줌
  - 메모리 보호: 프로세스는 독립적인 메모리 공간 필요. 잘못된 접근 시 trap 발생
    - base = 메모리상의 프로세스 시작 주소를 물리주소로 저장
    - limit = 프로세스의 사이즈 저장
    - 안전성을 위해 base와 limit 레지스터는 커널 모드에서만 수정 가능하도록 설계 
- 메모리 공간이 한정적이라서, 더 많은 메모리를 제공하기 위해 **가상 주소**개념 등장.
- 이 가상 주소에서 실제 데이터가 담겨있는 곳에 접근하기 위해선 빠른 주소 변환이 필요하다. = MMU



#### MMU 역할

- Physical Address로 직접 접근하지 않아도 
- 프로세스의 크기가 실제 메모리 용량을 초과해도 실행 가능



#### over allocating(과할당)

> 실제 메모리의 크기보다 더 큰 크기의 메모리를 프로세스에 할당

1. 프로세스 실행 도중 **페이지 폴트**발생
2. 페이지 폴트를 발생시킨 페이지 위치를 디스크에서 찾음
3. 메모리의 빈 프레임에 페이지를 올려야 하는데, 모든 메모리가 사용중이라 빈 프레임이 없음



[해결 방법]

1. 메모리에 올라와있는 한 프로세스를 **종료**시켜 빈 프레임을 얻음 (사실상 쓰지마) => 사용자에게 들킬 가능성 매우 높음
   - (페이징 기법은 사용자 모르게 시스템 능률을 높이기 위해 선택한 일이므로 들키지 않게 처리해야한다)
2. 프로세스 하나를 **Swap Out**하고, 이 공간을 빈 프레임으로 활용





# 메모리 관리 방법

다중 프로그래밍 시스템에서 여러 프로세스를 수용하기 위해 주기억장치를 동적 분할하는 메모리 관리 작업 필요



### 1. 연속 메모리 관리

프로그램 전체가 하나의 커다란 공간에 **연속적으로** 할당되어야 한다.

- 고정 분할 기법 = 주기억장치가 고정된 파티션으로 분할(내부 단편화 발생)
- 동적 분할 기법 = 파티션들이 동적 생성되며 자신의 크기와 같은 파티션에 적재(외부 단편화 발생)ㅋㅋㅋ 먼소리야ㅠ



### 2. 불연속 메모리 관리

프로그램의 일부가 서로 다른 주소 공간에 할당될 수 있는 기법

- 페이지 = 고정 사이즈의 작은 **프로세스 조각**
- 프레임 = 페이지 크기와 같은 주기억장치 **메모리 조각**
- 단편화 = 기억 장치에 빈 공간 생김 or 자료가 여러 조각으로 나뉨
- 세그먼트 = 서로 다른 크기를 가진 논리적 블록이 **연속적 공간**에 배치



#### 단순 페이징

각 프로세스를 프레임들과 같은 길이를 가진 균등 페이지로 나눈다. 외부 단편화 X, 소량의 내부 단편화



#### 단순 세그먼테이션

각 프로세스를 여러 세그먼트로 나눈다. 외부 단편화 O, 내부 단편화 X(메모리 사용 효율 개선, 동적 분할을 통한 오버헤드 감소)



#### 가상 메모리 페이징

단순 페이징과 비교해 프로세스 페이지 전부를 로드시키진 않는다. 필요한 페이지가 있다면 자동으로 부른다.

외부 단편화 X, 대신 복잡한 메모리 관리로 오버헤드 발생



#### 가상 메모리 세그먼테이션

필요하지 않은 세그먼트는 로드하지않고, 나중에 필요하면 부름.

내부 단편화 X,  복잡한 메모리 관리로 오버헤드 발생











## 페이지 교체

> over allocating이 발생했을 때, 프로세스 하나를 swap out해서 빈 프레임을 확보하는 것

(이게 무슨 소리야)

1. 프로세스 실행 도중 페이지 폴트 발생
2. 페이지 폴트를 발생시킨 페이지 위치를 디스크에서 찾음
3. 메모리에 빈 프레임이 있는지 확인
   - 빈 프레임이 있으면 해당 프레임 사용
   - 없으면 victim 프레임을 선정해 디스크에 기록하고, 페이지 테이블 업데이트
4. 빈 프레임에 페이지 폴트가 발생한 페이지를 올리고, 페이지 테이블 업데이트



페이지 교체가 이루어지면 아무일이 없던것 처럼 프로세스를 계속 수행시켜주면서 사용자가 알지 못하도록 해야 함

이때, 아무일도 일어나지 않은 것처럼 하려면, 페이지 교체 당시 **오버헤드를 최대한 줄여야 함**



### 오버헤드를 감소시키는 방법

1. 변경비트를 모든 페이지마다 두고, victim이 정해지면 해당 페이지의 비트 확인
   1. set = 디스크 상의 페이지 내용 != 메모리 상의 페이지 내용 (디스크에 기록 필요)
   2. clear = 디스크 상의 페이지 내용 == 메모리 상의 페이지 내용

2. 적절한 페이지 교체 알고리즘
   1. FIFO
   2. OPT
   3. LRU





# Cache Memory

> 주기억장치에 저장된 내용의 일부를 임시로 저장해두는 기억장치
>
> CPU와 주기억장치의 속도 차이로 성능 저하를 방지하기 위함

CPU가 이미 접근한 데이터를 다시 접근할 때, 메모리 참조 & 인출 과정의 비용을 줄이기 위해 캐시에 저장해둔 데이터 활용

1. CPU에서 주소 전달
2. 캐시에 존재하는지 확인
   - 존재 `Hit` = 해당 명령어를 CPU로 전송
   - 비존재 `Miss` = 주기억 장치 접근 -> 해당 명령어를 가진 데이터 인출 -> 해당 명령어 데이터를 캐시에 저장 -> 해당 명령어를 CPU로 전송 (왜 명령어야..? 아깐 주소 전달이었는데...)



비용을 줄이기 위해선  CPU가 어떤 데이터를 원할지 어느정도 **예측**할 수 있어야 함 = **지역성의 원리**

#### 시간 지역성

> 최근에 참조된 것은 곧 다음에도 참조된다.



#### 공간 지역성

> 참조된 주소와 인접한 주소의 내용이 다시 참조된다.



#### 캐싱라인

> 자료구조를 활용해 캐시를 데이터에 저장하는 것