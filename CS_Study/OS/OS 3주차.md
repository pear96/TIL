# Memory

> 프로그램을 실행하기 위해 필요한 정보들은 메모리에 저장된다. 작업의 처리 대상 또는 결과를 저장하는 공간



## Main Memory

- 프로세스가 실행되려면 프로그램이 메모리에 올라와야한다.
- 주소가 할당된 *일련의 바이트*들로 구성

- CPU는 **레지스터**가 지시하는대로 메모리에 접근하여 다음에 수행할 명령어를 가져옴
- 명령어 수행 시 메모리에 필요한 데이터가 없으면 해당 데이터를 우선 가져와야 함(MMU)
- 사용자 프로세스 영역 + OS 상주 영역으로 할당됨



### Memory Management Unit

- **논리 주소를 물리 주소로 변환하는 하드웨어 기기**
  - **논리 주소(가상 주소) = CPU가 사용하는 주소,** 각 프로세스마다 독립적으로 가짐
  - 물리 주소 = 메모리에 실제 올라가는 위치

- 주소 바인딩
  - compile time binding = 컴파일시 물리적 메모리 주소 정함
  - load time binding = loader의 책임 하에 물리적 메모리 주소 부여
  - execution time binding = 수행이 시작된 이후에도 프로세스의 메모리 상 위치를 옮길 수 있음, CPU가 주소를 참조할 때마다 binding 점검

- 메모리 보호, 캐시 관리 등 CPU가 메모리에 접근하는 것을 총 관리해줌
  - 메모리 보호: 프로세스는 독립적인 메모리 공간 필요. 잘못된 접근 시 trap 발생
    - base = 메모리상의 프로세스 시작 주소를 물리주소로 저장
    - limit = 프로세스의 사이즈 저장
    - 안전성을 위해 base와 limit 레지스터는 커널 모드에서만 수정 가능하도록 설계 
- 메모리 공간이 한정적이라서, 더 많은 메모리를 제공하기 위해 **가상 주소**개념 등장.
- 이 가상 주소에서 실제 데이터가 담겨있는 곳에 접근하기 위해선 빠른 주소 변환이 필요하다. = MMU





#### MMU 역할

- Physical Address로 직접 접근하지 않아도 
- 프로세스의 크기가 실제 메모리 용량을 초과해도 실행 가능



#### over allocating(과할당)

> 실제 메모리의 크기보다 더 큰 크기의 메모리를 프로세스에 할당

1. 프로세스 실행 도중 **페이지 폴트**발생
2. 페이지 폴트를 발생시킨 페이지 위치를 디스크에서 찾음
3. 메모리의 빈 프레임에 페이지를 올려야 하는데, 모든 메모리가 사용중이라 빈 프레임이 없음



[해결 방법]

1. 메모리에 올라와있는 한 프로세스를 **종료**시켜 빈 프레임을 얻음 (사실상 쓰지마) => 사용자에게 들킬 가능성 매우 높음
   - (페이징 기법은 사용자 모르게 시스템 능률을 높이기 위해 선택한 일이므로 들키지 않게 처리해야한다)
2. 프로세스 하나를 **Swap Out**하고, 이 공간을 빈 프레임으로 활용





### 동적 로딩

- 프로세스 전체의 메모리에 미리 다 올리지 않고, 해당 루틴이 불려질 때 메모리에 load
- 메모리 사용성 향상 / 가끔씩 사용되는 많은 양의 코드에 유용
- 운영체제의 특별한 지원 필요 없음



### Overlays

- 메모리에 프로세스 부분 중 실제 필요한 정보만 올림
- 프로세스 크기가 메모리보다 클 때
- 프로그래밍이 매우 복잡



### Swapping

> 프로세스를 일시적으로 메모리에서 backing store로 쫓아내는 것



- Backing store(디스크) = 많은 사용자의 프로세스 이미지를 담을 만큼 충분히 빠르고 큰 저장 공간
- Swap in / Swap out
  - 일반적으로 중기 스케줄러에 의해 swap out 할 프로세스 선정
  - 우선순위에 따라 프로세스 결정
  - 







# 메모리 관리 방법

다중 프로그래밍 시스템에서 여러 프로세스를 수용하기 위해 주기억장치를 동적 분할하는 메모리 관리 작업 필요

![image-20220605041528778](https://github.com/pear96/cs-zz/raw/main/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/os.assets/image-20220605041528778.png)

### 1. 연속 메모리 관리

프로그램 전체가 하나의 커다란 공간에 **연속적으로** 할당되어야 한다.

- 고정 분할 기법 
  - 물리적 메모리를 영구적 파티션으로 나눔
  - 파티션당 하나의 프로그램
  - 융통성이 없다
  - 내부 단편화, 외부 단편화 발생

- 동적 분할 기법 
  - 프로그램의 크기 고려
  - 분할 크기, 개수가 동적으로 변함
  - 외부 단편화 발생

- `Hole` : 가용 메모리 공간
  - 다양한 크기의 hole이 메모리 여러 곳에 흩어져있으며
  - 프로세스가 도착하면 hole 할당

- Dynamic Storage-Allocation Problem
  - First-Fit : 원하는 크기 이상 중 처음 찾는 hole
  - Best-Fit : 가장 원하는 크기에 근접한 hole
  - Worst-Fit : 가장 큰 hole 할당


#### compaction 외부 단편화 해결방법

- 사용중인 메모리 영역을 한군데에 몰고 큰 block 생성
- 매우 비용이 많이 든다.
- 프로세스의 주소가 실행 시간에 동적으로 재배치 가능한 경우에만 사용





### 2. 불연속 메모리 관리

프로그램의 일부가 서로 다른 주소 공간에 할당될 수 있는 기법

- 페이지 = 고정 사이즈의 작은 **프로세스 조각**
- 프레임 = 페이지 크기와 같은 주기억장치 **메모리 조각**
- 단편화 = 기억 장치에 빈 공간 생김 or 자료가 여러 조각으로 나뉨
- 세그먼트 = 서로 다른 크기를 가진 논리적 블록이 **연속적 공간**에 배치



#### 단순 페이징

각 프로세스를 프레임들과 같은 길이를 가진 **균등 페이지로** 나눈다.

- physical memory를 동일한 크기의 frame으로 나눔
- logical memory를 동일 크기의 page로 나눔(frame과 같은 크기)
- 모든 가용 frame들을 관리
- page table을 사용하여 logical address를 physical address로 변환
- External fragmentation 발생 안함
- Internal fragmentation 발생 가능

##### Page Table

- main memory에 상주
- page table 접근 1번, 실제 data/instruction 접근 1번



##### Two-Level Page Table

- 대의 컴퓨터는 address space가 매우 큰 프로그램 지원
  - 32 bit address 사용시: 2 32B (4GB)의 주소 공간
  - 각 page entry가 4K시 1M개의 page table entry필요
  - 그러나, 대부분의 프로그램은 4G의 주소 공간 중 지극히 일부분만 사용하므로 page table 공간이 심하게 낭비됨
- page table 자체를 page로 구성
- 사용되지 않는 주소 공간에 대한 outer page table의 엔트리 값은 NULL(대응하는 inner page table이 없음)

#### 단순 세그먼테이션

> 프로그램은 의미 단위인 여러 개의 segment로 구성

각 프로세스를 여러 세그먼트로 나눈다. 외부 단편화 O, 내부 단편화 X(메모리 사용 효율 개선, 동적 분할을 통한 오버헤드 감소)

- 작게는 프로그램을 구성하는 함수 하나하나를 세그먼트로 정의
- 크게는 프로그램 전체를 하나의 세그먼트로 정의 가능
- 일반적으로는 code, data, stack 부분이 하나의 세그먼트로 정의됨



#### 가상 메모리 페이징

단순 페이징과 비교해 프로세스 페이지 전부를 로드시키진 않는다. 필요한 페이지가 있다면 자동으로 부른다.

외부 단편화 X, 대신 복잡한 메모리 관리로 오버헤드 발생



#### 가상 메모리 세그먼테이션

필요하지 않은 세그먼트는 로드하지않고, 나중에 필요하면 부름.

내부 단편화 X,  복잡한 메모리 관리로 오버헤드 발생







## 페이지 교체

> over allocating이 발생했을 때, 프로세스 하나를 swap out해서 빈 프레임을 확보하는 것

(이게 무슨 소리야)

1. 프로세스 실행 도중 페이지 폴트 발생
2. 페이지 폴트를 발생시킨 페이지 위치를 디스크에서 찾음
3. 메모리에 빈 프레임이 있는지 확인
   - 빈 프레임이 있으면 해당 프레임 사용
   - 없으면 victim 프레임을 선정해 디스크에 기록하고, 페이지 테이블 업데이트
4. 빈 프레임에 페이지 폴트가 발생한 페이지를 올리고, 페이지 테이블 업데이트



페이지 교체가 이루어지면 아무일이 없던것 처럼 프로세스를 계속 수행시켜주면서 사용자가 알지 못하도록 해야 함

이때, 아무일도 일어나지 않은 것처럼 하려면, 페이지 교체 당시 **오버헤드를 최대한 줄여야 함**



### 오버헤드를 감소시키는 방법

1. 변경비트를 모든 페이지마다 두고, victim이 정해지면 해당 페이지의 비트 확인
   1. set = 디스크 상의 페이지 내용 != 메모리 상의 페이지 내용 (디스크에 기록 필요)
   2. clear = 디스크 상의 페이지 내용 == 메모리 상의 페이지 내용

2. 적절한 페이지 교체 알고리즘
   1. FIFO
   2. OPT
   3. LRU





# Cache Memory

> 주기억장치에 저장된 내용의 일부를 임시로 저장해두는 기억장치
>
> CPU와 주기억장치의 속도 차이로 성능 저하를 방지하기 위함

CPU가 이미 접근한 데이터를 다시 접근할 때, 메모리 참조 & 인출 과정의 비용을 줄이기 위해 캐시에 저장해둔 데이터 활용

1. CPU에서 주소 전달
2. 캐시에 존재하는지 확인
   - 존재 `Hit` = 해당 명령어를 CPU로 전송
   - 비존재 `Miss` = 주기억 장치 접근 -> 해당 명령어를 가진 데이터 인출 -> 해당 명령어 데이터를 캐시에 저장 -> 해당 명령어를 CPU로 전송 (왜 명령어야..? 아깐 주소 전달이었는데...)



비용을 줄이기 위해선  CPU가 어떤 데이터를 원할지 어느정도 **예측**할 수 있어야 함 = **지역성의 원리**

#### 시간 지역성

> 최근에 참조된 것은 곧 다음에도 참조된다.



#### 공간 지역성

> 참조된 주소와 인접한 주소의 내용이 다시 참조된다.



#### 캐싱라인

> 자료구조를 활용해 캐시를 데이터에 저장하는 것



## Trashing

- 프로세스의 원활한 수행에 필요한 최소한의 page frame 수를 할당 받지 못한 경우 발생
- Page fault rate이 매우 높아짐
- CPU utilization이 낮아짐
- OS는 **MPD(Multiprogramming degree)를 높여야 한다고 판단**
- 또 다른 프로세스가 시스템에 추가됨(higher MPD)
- 프로세스 당 할당된 frame의 수가 더욱 감소
- 프로세스는 page의 swap in / swap out 으로 매우 바쁨
- 대부분의 시간에 CPU는 한가함
- low throughput









# 질문

[출처](https://imbf.github.io/interview/2021/02/28/NAVER-Practical-Interview-Preparation-2.html)

### Swapping에 대해서 알려주실 수 있나요?

**Swapping이란 CPU 할당 시간이 끝난 프로세스의 메모리를 디스크로 보내고 다른 프로세스를 메모리로 불러 들이는 것을 의미합니다.** 프로세스를 디스크에서 메모리로 불러오는 과정을 Swap-in, 보조 기억장치로 내보내는 과정을 Swap-out 이라고 합니다.

### Swapping을 하면서 발생할 수 있는 문제점에 대해서 알고 있으시나요?

네! Swapping을 하면서 발생할 수 있는 대표적인 문제는 **단편화(Fragmentation) 문제** 입니다. **단편화(Fragmentation)란 프로세스들이 메모리에 적재되고 제거되는 일이 반복되면서 메모리 사이 사이에 사용하지 못할 만큼의 작은 자유공간들을 의미합니다.**

### 단편화(Fragmentation)는 어떻게 나눌 수 있을까요?

단편화 종류는 크게 외부 단편화(External Fragmentation)와 내부 단편화(Internal Fragmentation)로 나눌 수 있습니다. **외부 단편화란 메모리에서 프로세스와 프로세스 사이에 남는 공간들을 의미하는 것이구요, 내부 단편화란 프로세스가 사용하는 메모리 공간 내부에서 사용하지 않고 남는 공간들을 의미합니다.**

### 외부 단편화를 해소하기 위한 방법은 무엇이 있을까요?

**외부 단편화를 없애기 위해서 프로세스가 사용하는 메모리 공간들을 한쪽으로 몰아 분산된 자유 공간을 확보하는 방법인 메모리 압축(Memory Compression)이 있습니다.**

### 외부 단편화를 해결할 수 있는 또 다른 방법인 페이징 기법에 대해서 들어보셨나요?

**페이징(Paging) 기법이란 물리 메모리를 Frame이라는 고정 크기로 분리하고, 논리 메모리는 페이지라 불리는 고정 크기의 블록으로 분리하는 기법입니다.** 즉, 하나의 프로세스가 사용하는 공간을 여러개의 페이지로 나뉘어서 논리 메모리에서 관리하고, 개별 페이지는 순서에 상관없이 물리 메모리의 프레임에 맵핑되어 저장하는 방법입니다.

> 페이징 기법을 통해서 외부 단편화는 없앨 수 있지만, 페이지의 크기는 정해져 있기 때문에 내부 단편화는 발생할 수 있습니다.

### 세그멘테이션이란 무엇일까요?

**세그멘테이션(Segmentation)은 프로세스를 물리적 크기의 단위가 아니라 논리적 내용의 단위인 세그먼트로 분할하여 메모리에 저장하는 방법입니다.** 논리적 내용의 단위로 분할된 세그먼트는 내부 단편화는 방지할 수 있지만 세그먼트별로 서로 단위가 다르기 때문에 외부 단편화가 발생하는 문제점이 존재합니다.

------

## Virtual Memory

------

### 가상 메모리란 무엇인가?

**가상 메모리를 통해 실제 물리 메모리 개념과 사용자의 논리 메모리 개념을 분리해서 프로세스 전체가 메모리에 올라오지 않더라도 프로그램의 실행이 가능하도록 하는 기법을 말합니다.**

### 가상 메모리를 도입할 시 어떠한 효과를 얻을 수 있나요?

**가상 메모리를 통해 프로그램의 일부분만 물리 메모리에 올릴 수 있게 되었고 이를 통해 물리 메모리 크기에 제약을 받지 않게 되었습니다.** 결국 더 많은 프로그램을 동시에 실행할 수 있게 되었고, swap에 필요한 입출력이 줄었기 때문에 프로그램들이 빠르게 실행되어지는 효과를 얻을 수 있습니다.

### 가상 주소 공간은 무엇인가요?

**가상 주소 공간이란 한 프로세스가 물리 메모리에 저장되는 논리적인 모습을 가상메모리에 구현한 공간을 의미합니다.** 프로세스가 요구하는 메모리 공간을 물리 메모리가 아닌 가상 메모리에서 제공함으로써 현재 직접적으로 필요치 않는 메모리 공간은 실제 물리 메모리에 올리지 않는 것으로 메모리를 절약할 수 있습니다.

> ### Tip
>
> - **가상 메모리는 시스템 라이브러리가 여러 프로세스들 사이에서 공유되어질 수 있도록 합니다.** 실제 물리 메모리는 공유되어지지만 각 프로세스는 각자 자신의 주소 공간처럼 인식합니다.
> - **프로세스들이 메모리를 공유하는 것을 가능하게 하고, 프로세스들은 공유 메모리를 통해 통신할 수 있습니다.** 이 또한 각 프로세스들은 공유 메모리를 각자 자신의 주소 공간처럼 인식하지만, 실제 물리 메모리는 공유되고 있습니다.

### 요구 페이징(Demand Paging)이란 무엇인가요?

요구 페이징(Demand Paging)이란 가상 메모리 시스템에서 많이 사용하는 메모리 관리 기법 중 하나로 **프로그램 실행 시작 시 초기에 필요한 페이지만 메모리에 Load하고 이후 실행 과정에서 페이지들이 실제로 필요할 때만 Load하는 방식을 의미합니다.**

### 페이지 교체 알고리즘이란 무엇인가요?

프로그램 실행시 모든 페이지가 물리 메모리에 올라오지 않기 때문에 실행 과정에서 프로세스의 동작에 필요한 페이지를 요청하는 과정이 필요합니다. **페이지를 요청하는 과정에서 페이지 부재(page fault)가 발생하게 되면, 원하는 페이지를 디스크에서 가져오게 되는데 물리 메모리가 모두 사용중인 상황이라면 페이지 교체가 이루어져야 합니다. 이러한 상황에서 사용하는 알고리즘을 페이지 교체 알고리즘이라고 합니다.**

### 페이지 교체 과정에 대해서 아시나요?

1. 디스크에서 필요한 페이지의 위치를 찾는다.
2. 물리 메모리에서 빈 페이지 프레임을 찾는다.
   1. 빈 프레임이 없을 경우 페이지 교체 알고리즘을 통해 희생될(victim) 페이지를 고른다.
   2. 희생될 페이지를 디스크에 기록하고, 관련 페이지 테이블을 수정한다.
3. 새롭게 비워진 페이지 테이블 내 프레임에 새 페이지를 읽어오고, 프레임 테이블을 수정한다.
4. 사용자 프로세스 재시작

### 페이지 교체 알고리즘에 대해서 알고계신 것 모두 말씀해주세요.

1. **FIFO(First-in-First-out) 페이지 교체 :** 먼저 메모리에 들어온 페이지 순서대로 페이지를 교체한다.
2. **최적(Optimal) 페이지 교체 :** 메모리에서 앞으로 가장 오랫동안 사용되지 않을 페이지를 찾아 교체한다.
3. **LRU(Least Recently Used) 페이지 교체 :** 메모리에서 가장 오랫동안 사용되지 않은 페이지를 선택하여 교체한다.
4. **LFU(Least Frequently Used) 페이지 교체 :** 메모리에서 가장 참조되지 않은 페이지를 선택하여 교체한다.
5. **MFU(Most Frequently Used) 페이지 교체 :** 메모리에서 가장 많이 참조되는 페이지를 선택하여 교체한다.

### Paging System에서 LRU, LFU 가능한가?

- 운영체제는 disk에 접근하는 I/O 작업이 일어났을 때에 관여하기 때문에 이미 물리적인 메모리에 올라와있는 page에 접근하는 것에 대한 정보를 얻기 어려움 > LRU, LFU 사용 불가

------

## Caching

------

### 캐싱(Caching)이란 무엇인가요?

**캐싱이란 특정 데이터를 빠르게 접근할 수 있도록 임시적인 저장 위치에 데이터를 저장해두는 방법을 의미합니다.** 캐싱을 통해서 속도가 빠른 장치와 느린 장치 사이에서 발생하는 병목 현상을 줄일 수 있습니다.

### 캐싱 작업시 가장 신경써야 하는 문제는 무엇인가요?

**캐시의 역할을 극대화 시키기 위해서는 얼마나 데이터가 많이 참조 되는지를 고려해서 많이 참조되는 데이터들을 캐싱해야 합니다. 즉, 적중률(hit ratio)를 극대화 시켜야 합니다.**

### 캐시 적중률(hit ratio)을 어떻게 극대화 시킬 수 있을까요?

적중률(hit ratio)을 극대화 시키기 위해서 **지역성(Locality)의 원리**를 사용할 수 있습니다. **지역성의 원리 즉, Locality Principle이란 메모리 내의 정보는 균일하게 Access 되는 것이 아닌 어느 한 순간에 특정 부분이 집중적으로 참조된다는 원리입니다.**

### Locality는 어떻게 나눌 수 있나요?

Locality는 크게 시간 지역성(Temporal Locality)과 공간 지역성(Spatial Locality)으로 나뉩니다. **시간 지역성이란 최근에 참조된 메모리의 특정 주소는 곧 다시 참조된다는 특성을 의미하구요, 공간 지역성이란 참조된 메모리의 주소와 인접한 주소의 내용이 곧 다시 참조된다는 특성을 의미합니다.**

### Caching Line이란 무엇인가요?

**캐시에 데이터를 저장할 때 특정 자료구조를 사용하여 묶음으로 저장하게 되는데 이를 캐싱 라인(Caching Line)이라고 합니다.** 프로세스는 다양한 주소에 있는 데이터를 사용하므로 빈번하게 사용하는 데이터의 주소 또한 흩어져 있습니다. 따라서 캐시에 저장하는 데이터에는 데이터의 메모리 주소 등을 기록해 둔 태그를 달아놓을 필요가 있다. 이러한 태그들의 묶음을 캐싱 라인이라고 하고 메모리로부터 데이터를 가져올 때도 캐싱 라인을 기준으로 가져옵니다.

> **캐싱 라인의 종류**
>
> 1. Full Associative
> 2. Set Associative
> 3. Direct Map