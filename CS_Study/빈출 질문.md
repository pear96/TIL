# Database

- Index란 무엇인지

  - 검색 성능을 높여주는 대표적인 방법 중 하나입니다. RDBMS는 B+Tree구조로 된 Index를 사용하여 검색 속도를 향상시킵니다.
  - **특정 column의 값(search key)을 기준으로 정렬**하여 **데이터의 물리적 위치(pointer)**와 함께 별도 파일에 저장합니다.
  - 순서대로 정렬된 search-key 값과 pointer만 저장하기 때문에 table보다 적은 공간을 차지합니다.
  - 대신 table 크기의 약 10% 크기의 추가 저장 공간이 필요하며, 데이터 변경이 잦을 경우 B+Tree의 구조가 변경될 수 있기 때문에 성능이 나빠질 수 있습니다.

- index의 필요성을 설명하시오

  - 검색 속도 향상을 위해 필요합니다. 특정 column에 대한 Index를 생성할 경우, 해당 속성에 대해 정렬되어 저장되어있기 때문에 Full table scan할 필요 없이 조건 검색 속도가 굉장히 빠릅니다.

- :star::star::star::star:index를 어느 column에 사용하는 것이 좋을지 설명하시오

  -  where 절에서 **자주 조회되고** + **수정 빈도가 낮으며** + **카디널리티가 높고(중복이 적고)** + **선택도가 낮은** 컬럼에 적합합니다.
    - Join은 두 테이블에서 일치하는 값을 찾아야 하므로, 많은 시간이 소요됩니다. 그러나 인덱스가 설정되어있다면 훨씬 빠르게 일치하는 레코드를 찾을 수 있습니다. 인덱스가 설정된 컬럼을 기준으로 join 연산을 수행하는 것은 보통 더 효과적입니다.
    - 데이터를 수정할 때마다 Index는 정렬을 다시 해야하므로 부하가 발생합니다.
    - 카디널리티(데이터 집합의 유니크한 값의 수)가 낮으면, (= 선택도(한 번의 조회 쿼리에 해당하는 레코드가 얼마나 존재하는지)가 높으면) 해당 인덱스가 가리키는 모든 레코드에 대해 다시 검색해야합니다. 여전히 많은 수의 데이터를 처리해야하므로, 검색 시간 단축에 효과가 없습니다.

  - 성별 컬럼에 index를 걸어주면 좋을까요?
    - 인덱스의 검색 효율은 데이터의 고유성에 크게 의존합니다. 카디널리티가 낮으면 인덱스는 레코드를 명확하게 구분하는데 별로 도움이 되지 않습니다. '남성' 값에 인덱스를 찾아도 여전히 많은 '남성'레코드를 모두 검색해야하기 때문입니다.

  - true, false 값을 갖는 컬럼에서 true 1%, false 99% 의 비율인 경우 index를 거는게 좋을까요?
    - false값의 선택도가 너무 높기 때문에 효율적이지 않습니다. 결국 false에 대해 검색할 경우, 인덱스를 거쳐가는 과정이 추가적인 오버헤드를 발생시키기 때문에 오히려 Full Scan보다 성능이 떨어질 수 있습니다.
  - Index를 쓰면 성능이 좋아지니까 모든 컬럼에 인덱스를 사용하면 성능이 더 좋겠네요?
    - index 생성은 테이블에 추가적인 오버헤드를 부과하고 디스크 공간을 차지하기 때문에, 필요한 인덱스만 생성해야합니다. 또한, 데이터를 수정하면 index는 매번 정렬을 다시해야합니다. 한 테이블에 index가 너무 많으면 데이터 수정시 소요되는 시간이 너무 길어질 수 있습니다.

- :star:데이터를 검색할 때, hash table의 시간복잡도는 O(1)이고, b+tree는 O(logN)으로 더 느리다. 왜 Index는 HashTable이 아니라 b+Tree로 구현되는지 설명하시오

  - HashTable을 사용하면 **하나의 데이터**를 탐색하는 시간은 O(1)로 B+Tree보다 빠르지만
  - 값이 정렬되어있지 않기 때문에 **부등호를 사용**하는 쿼리에 대해서는 O(N)의 시간으로 전체 요소를 검색해야하기 때문에 데이터를 정렬하는 B+Tree 구조를 사용합니다.
  - 또한 B+Tree는 리프노트가 연결리스트로 연결되어있어 범위 검색에 유리합니다.

- :star::star:Transaction을 설명하시오

  - DB 내에서 수행되는 최소 작업 단위이며, DB의 무결성을 유지하고 상태를 변화시키는 역할을 합니다. 장애 발생시 데이터를 복구하는 작업의 단위가 됩니다.
  - 하나 이상의 쿼리를 포함해야하고, 원자성, 일관성, 고립성, 지속성의 규칙을 만족해야합니다.
    - 원자성 : 트랜잭션에 포함된 작업은 전부 수행되거나, 전부 수행되지 말아야 합니다.
    - 일관성 : 허용된 방식으로만 데이터를 변경해야한다.
    - 고립성 : 다른 트랜잭션의 연산 작업에 끼어들 수 없습니다.
      - 동시성제어 : 수정 중에 있는 트랜잭션은 해당 데이터를 다른 트랜잭션이 접근하지 못하도록 잠급니다. Lock이 걸린 데이터는 Unlock이 될 때까지 다른 트랜잭션들이 대기해야합니다.
    - 지속성 : 트랜잭션을 성공적으로 완료하면 DB에 영원히 반영되어야합니다.
  - COMMIT : 트랜잭션으로 변경된 내용이 모두 영구적으로 저장되는 것
  - ROLLBACK : 트랜잭션을 수행하기 전으로 되돌리는 것
  - => 데이터 무결성 보장. 데이터 무결성 = 정확성, 일관성, 유효성 유지
    - 개체 무결성 : PK는 빈값 X
    - 참조 무결성 : 참조 관계의 테이블은 항상 일관된 값 유지
    - 고유 무결성 : 특정 속성에 대해 고유한 값
    - NULL 무결성 : NULL X

- :star: DeadLock을 설명하시오

  - 여러 트랜잭션이 각각 자신의 데이터에 대해 LOCK을 획득한 상태에서 상대방 데이터 접근하고자 대기할 때, 서로 영원히 기다리는 상태를 말합니다.
  - Deadlock을 해결하려면?
    - 각 트랜잭션이 실행되기 전에 필요한 데이터를 한번에 요청합니다.
    - 자원 할당시 데드락으로 이어질 가능성이 있다면 할당을 보류합니다. 자원 할당 상태와 트랜잭션의 자원 요청 정보를 실시간으로 관리해야합니다.
    - deadlock이 발생하면 이를 감지하고 회복시킵니다. 데드락을 정기적으로 탐지하고 데드락 발생시 롤백등의 조치를 취합니다.

- :star: RDB VS NoSQL을 비교설명하시오

  - 관계형 데이터 베이스는 행과 열을 가지는 테이블 형식으로 데이터를 저장하는 데이터베이스입니다.
  - NoSQL은 테이블이 아닌 키-값 쌍, Json, 그래프 등의 형태로 데이터를 저장하는 데이터베이스입니다.
  - RDB는 정형화된 데이터를 처리하는데 적합하며, NoSQL은 다양한 형태의 데이터를 쉽게 저장하고 처리하는데 적합합니다.
  - RDB는 ACID 트랜잭션을 지원하며 데이터의 일관성을 보장합니다. NoSQL은 일관성을 다소 희생하더라도 확장성, 성능을 우선합니다.
  - RDB는 데이터 구조가 변경될 여지가 없고, update가 잦은 경우에 적합합니다.
  - NoSQL은 데이터의 구조가 정확히 정해지지 않고, 수정보다 조회가 많은 경우, 또는 데이터 양이 많은 경우 scale-out이 가능하기 때문에 적합합니다.
    - NoSQL은 수평확장을 위해 설계된 데이터베이스라 scale-out에 효과적이다.
      1. 분산처리 : 여러 서버에 데이터 분산 저장, 동시에 여러 작업 처리 가능
      2. 데이터 복제 지원
      3. 스키마 유연성 : 데이터 구조 변화에 대한 비용이 적다.
      4. 빠른 응답 시간 : 빠른 조회에 최적화
    - 데이터 양이 늘어나거나, 요청이 증가함에 따라 서버를 추가하기만 하면 된다.

- Primary key를 설명하시오

  - 각 row를 유일하게 구분하는 컬럼을 말합니다. 중복된 값, NULL값을 가질 수 없습니다. 기본키는 테이블 당 1개만 지정해야 합니다.
  - 슈퍼키 : 각 ROW를 유일하게 식별할 수 있는 속성 (유일성)                           
  - 후보키 : 각 ROW를 유일하게 식별할 수 있는 최소한의 속성 (유일성 + 최소성)
  - 대체키 : 후보키가 2개 이상일 경우, 기본키를 제외한 후보키들
  - 외래키 : 다른 테이블의 기본 키를 그대로 참조하는 값. 테이블 간의 관계를 식별하는데 사용합니다.
  - 복합키 : 2개 이상의 컬럼을 결합하여 각 ROW를 유일하게 구분하는 후보키

- 관계형 데이터베이스의 N:M 관계를 설명하시오

  - 양쪽 엔티티 모두가 서로에게 1:N 관계를 지닌 구조입니다.
  - Mapping table을 통해 관계를 맺는다.
  - `1:N` : 하나의 테이블이 관계를 맺은 테이블의 '여러' 객체를 가질 수 있는 구조

- left outer join, inner join의 차이를 설명하시오

  - Join이란 두개 이상의 테이블을 연결하여 하나의 테이블을 결과로 만들어내는 것입니다.
  - inner join은 join한 테이블들에 공통적으로 포함된 내용만 join 합니다.
  - left outer join은 왼쪽 테이블의 모든 행에 대해 join합니다.





+) 궁금증

- mysql의 클러스터 인덱스를 설정하는게 어떤 점에서 좋은가요?? 그렇다면 pk를 조회할 때 인덱스가 설정되어있지 않다면 DB를 full scan 하나요? 그렇다면 모든 테이블에 클러스터 인덱스를 설정하는게 좋은가요?

  - 클러스터 인덱스는 특정 방식으로 데이터베이스 내 데이터를 **물리적으로 재정렬**합니다. MySQL에서 InnoDB 스토리지 엔진을 사용하는 경우, **기본 키(Primary Key, PK)는 클러스터 인덱스로 자동 설정**됩니다. 클러스터 인덱스의 장점은 다음과 같습니다:

    1. 데이터 접근 속도: 클러스터 인덱스는 테이블의 데이터를 인덱스 키 순서대로 물리적으로 재정렬합니다. 이는 해당 키를 기준으로 데이터를 검색할 때 빠른 속도를 제공합니다.
    2. 범위 쿼리의 성능 향상: 인덱스 키의 값이 연속적인 범위로 검색되는 경우, **클러스터 인덱스는 해당 범위의 모든 값이 물리적으로 가까운 곳에 위치**하므로 이러한 쿼리의 성능을 크게 향상시킵니다.
    3. 데이터의 정렬: 클러스터 인덱스는 테이블의 데이터를 특정 순서로 유지합니다. 이는 정렬된 데이터를 필요로 하는 쿼리에 유용합니다.

    그러나 PK에 클러스터 인덱스가 설정되어 있지 않다면, 데이터를 찾기 위해 테이블 전체를 스캔해야 할 수 있습니다. 이는 성능에 부담을 줄 수 있습니다.

    그럼에도 불구하고, 모든 테이블에 클러스터 인덱스를 설정하는 것이 항상 좋은 것은 아닙니다. 클러스터 인덱스는 데이터를 물리적으로 재정렬하기 때문에, 데이터의 삽입, 삭제, 업데이트가 발생할 때마다 해당 작업을 수행해야 합니다. 이는 성능에 부담을 줄 수 있습니다. 따라서 테이블의 사용 패턴, 쿼리의 특성 등을 고려하여 인덱스를 결정하는 것이 중요합니다.























---

# 네트워크

- OSI 7계층과 TCP/IP 4계층을 비교 설명하시오
  - OSI 7계층은 **네트워크 통신을 표준화**한 모델로 통신 시스템을 7단계로 나눈 것이고, TCP/IP는 **실제 구현된 구조**로 나눈것입니다.
  - OSI 7계층은 물리, 데이터 링크, 네트워크, 전송, 세션, 표현, 응용 레이어로 나뉩니다.
  - TCP/IP 4계층은 네트워크 인터페이스, 네트워크, 전송, 응용 레이어로 나뉩니다.
    - TCP/IP는 네트워크 인터페이스를 물리와 데이터 링크로 나누어 5계층이 되었습니다.
- 캡슐화 : 통신 정보를 헤더에 담아 하위 프로토콜에 전달
- 역캡슐화 : 캡슐화의 역순으로 헤더를 하나씩 제거하며 상위 계층으로 데이터 전달
- :star:TCP vs UDP를 비교 설명하시오
  - TCP는 연결형, 신뢰성 전송 프로토콜. 3-way-handshake로 전송 계층 사이에 논리적 연결을 설립. 신뢰성 보장을 위해 흐름제어, 오류제어, 혼잡제어를 실행합니다.
    - 흐름 제어 : 데이터를 보내고 받는 속도의 균형을 맞춤
    - 오류 제어 : 훼손된 segment 감지 및 재전송, 순서에 맞지 않는 segment 정렬
  - UDP는 단순한 방식으로 데이터를 전송하기 때문에 신뢰성이 낮다. 스트리밍과 같이 중간에 데이터가 손실되어도 괜찮은 경우에 사용함.
- 3-way handshake는 무엇이고 각 과정은 어떻게 되는지 설명하시오
  - 3-way-handshake는 클라이언트가 서버에 HTTP 요청을 보내기 위해 TCP 연결이 수립되는 과정을 의미합니다.
  - 우선 클라이언트에서 연결 요청을 위해 SYN 패킷을 보냅니다. 서버는 SYN 패킷을 받고, 다시 SYN 패킷과 함께 연결을 수락하는 ACK 패킷을 보냅니다. 이후 클라이언트가 다시 연결 수립을 승낙하는 ACK를 서버로 보내면 TCP 연결이 수립됩니다.
- 4-way-handshaking
  - 클라이언트가 세션 종료를 위해 FIN 패킷 보냄
  - 서버가 ACK 패킷 보내고 프로세스 종료를 기다림. 
  - 서버에서 프로세스가 종료되면 FIN 패킷을 클라이언트에 보냄.
  - FIN 패킷을 받은 클라이언트가 서버에 ACK 패킷을 보냄.
  - 서버가 ACK를 받으면 연결 종료.
- HTTP를 설명하시오
  - HyperText Transport Protocol
  - 서버-클라이언트 모델을 따르며 요청-응답 구조로 웹 상에서 정보를 주고받는 프로토콜
  - Connectionless : 요청에 대한 응답을 받으면 연결을 끊음으로써 많은 사람이 웹을 이용하더라도 동시 접속을 최소화하여 최대한 많은 요청 처리
  - Statless : 그러나 Connectionless로 인해, 클라이언트의 이전 상태를 알 수 없다는 특징. 이를 극복하기 위해 cookie, session, jwt 활용
- :star::star:HTTP Request Method중 GET vs POST를 비교 설명하시오
  - GET : 클라이언트가 서버에 데이터를 요청할 때 사용하며 url 주소 끝에 key-value 쌍으로 쿼리 스트링을 만들어 전송. 캐싱이 가능하여 요청한 적이 있는 결과를 브라우저가 저장하고 재사용 가능
  - POST : 클라이언트가 서버에 데이터를 전달할 때 사용하며, body에 필요한 데이터를 담아서 전달함. 
  - PUT : 특정 자원을 전부 수정할 때
  - PATCH : 특정 자원의 일부를 수정할 때
- HTTP Status Code를 설명하시오
  - 클라이언트 요청에 대한 서버의 응답 코드로, 상태 코드를 통해 요청의 처리 결과를 알 수 있습니다. 100번대 부터 500번대 까지 총 5개의 클래스로 구분.
    - 100 : 요청 받았으며 작업 계속
    - 200 : 성공
    - 300 : redirect
    - 400 : 실패 (잘못된 요청)
    - 500 : 실패 (서버 에러)
- :star::star:`www.google.com`을 주소창에 입력시, 화면이 나오기까지의 과정을 네트워크 관점으로 설명하시오
  - 입력받은 url이 도메인인지 확인. 요청을 보내기 위해선 해당 서버의 IP 주소가 필요하다.
  - 먼저 브라우저에서 DNS 캐시를 확인하고 없다면 OS의 host 파일을, 공유기의 캐시도 확인한다. 공유기에서도 못 찾는다면 이제 ISP를 통해 DNS 질의를 요청한다. 
  - 도메인에 해당하는 아이피를 알았다면, HTTP 요청을 위해 TCP 요청을 보낸다. 3-way-handshake과정을 거쳐 해당 서버와 연결을 수립한다. 
  - 연결이 된 상태에서 HTTP 요청을 보내고, 응답을 받는다. 받은 HTTP 응답을 HTML, Javascript, CSS로 파싱하여 브라우저에 렌더링 한다.
  - 서버와의 연결을 종료할 땐 4-way-handshake로 서버와의 연결을 끊는다.
- :star:쿠키와 세션의 차이점을 설명하시오
  - 쿠키는 클라이언트에 저장되고, 세션은 서버에 저장된다는 차이가 있습니다.
  - 쿠키는 로컬 PC에 저장된다는 점에서 속도는 빠르지만 보안에 취약합니다.
  - 세션은 서버에서 조회하기 때문에 쿠키보다는 속도가 느리지만 보안성이 우수합니다.
  - 클라이언트가 서버에 요청을 보내고, 서버가 쿠키를 생성해서 HTTP 응답에 포함하여 클라이언트에 전달합니다. 이후 클라이언트는 로컬 PC에 저장된 쿠키의 정보를 요청에 담아 서버에 보낼 수 있습니다.
  - 클라이언트가 서버에 요청을 보내고, 서버는 쿠키를 확인하여 클라이언트가 session-id를 보냈는지 확인합니다. session-id가 존재하지 않는다면 서버는 생성하여 클라이언트에게 응답합니다. 
- 세션이 보안도 좋은데 쿠키를 사용하는 이유는?
  - 세션이 보안이 좋지만 서버에 데이터를 저장한다는 점에서 서버의 자원 사용하기 때문에 서버에 부하를 준다.
  - 쿠키와 세션을 적절하게 병행 사용하여 서버의 자원 낭비를 방지하고 속도를 높인다.
- 쿠키의 사용 예시
  - 로그인, 장바구니, 테마, 광고 개인화를 위한 트래킹
- 쿠키와 세션을 이용한 로그인 방식을 화이트보드에 설명하시오
  - 클라이언트가 로그인을 하면 서버는 회원 정보를 대조하고, 회원 정보 세션을 session storage에 저장한다. 
  - 응답에 session-id를 포함하여 클라이언트에게 전달한다.
  - 이후 클라이언트는 서버에 요청할 때 session-id를 포함하여 요청을 보내게 된다.
  - 서버는 session storage의 정보와 대조하고 클라이언트 정보를 바탕으로 응답을 전달한다.
    -  세션 하이재킹을 방지하기 위해 session 만료시간을 설정하거나 HTTPS를 사용한다.
- url과 uri의 차이
  - url : uri의 하위 집합으로, 리소스의 '위치'를 지정. 
  - uri : 웹 리소스를 고유하게 식별하는 식별자.



---

# 운영체제

- Process를 설명하시오
  - 프로그램이 메모리에 올라가 CPU를 할당받아 실행되는 것
  - 메모리 = CPU가 직접 접근할 수 있는 컴퓨터 내부의 기억장치, 프로그램이 CPU에서 실행되려면 메모리에 적재되어있어야한다.
  - +) 레지스터에 CPU가 다음에 실행해야하는 **'코드의 주소값'**이 저장되어있다.
- Process 메모리 영역(code, data, stack, heap)에 대해 설명
  - 메모리 영역을 나눈 이유 : 데이터를 공유하여 메모리 사용량을 줄이기 위함
  - Code : 실행할 프로그램의 **코드**. 정적
  - Data : **전역**변수 static 변수 (컴파일 완료 시 data 영역의 주소값을 가리킴. 정적)
  - Stack : **로컬**변수 매개 변수, 함수 (컴파일 시 영역의 크기 결정. 동적이라 stack overflow 발생 가능)
  - Heap : 프로그래머가 **직접 공간**을 할당,해제 하는 영역 (런타임 + 동적), GC에 의해 정리
- :star::star::star::star: Multi process를 설명하시오
  - 2개 이상의 프로세스가 동시에 실행되는 것. 동시성과 병렬성 두 가지의 의미
  - 병렬성 : CPU 코어가 여러개일 때, core마다 프로세스를 연산함으로써 동시에 실행
  - 동시성 : CPU 코어가 1개일 때, 여러 프로세스를 짧은 시간동안 번갈아 가면서 연산 (시분할 시스템)
- Process의 context는 무엇인가요? 프로세스의 실행 상태를 나타내는 정보의 집합. 프로세스가 일시 중단되었다가 다시 실행될 때, 이전 상태로 복원할 때 사용. PCB에 저장
- context switching : 다른 프로세스로 CPU 제어권을 넘겨주는 것. 이전 프로세스의 context를 PCB에 보관하고, 새로운 프로세스의 PCB를 읽어 보관된 상태 복구
  - 기존의 프로세스 컨텍스트를 저장하고, 새로운 프로세스의 컨텍스트로 교체하는 과정에서 CPU는 아무 일도 할수 없기 때문에 오버헤드(처리를 위한 간접적인 시간/메모리)가 발생한다.
- PCB(Process Control Block)에 저장되는 것들은 무엇이 있나요? 
  - 프로세스 상태 + 프로세스 번호 + 프로그램 카운터(프로세스가 다음에 실행할 명령어 주소) + 레지스터 값 + 메모리 제한
- process의 state에는 어떤 것들이 있나요?
  - Running : 프로세스가 CPU를 할당받아 현재 실행 중
  - Ready : 프로세스가 CPU를 할당받을 준비가 되었지만, 아직 실행되진 않음
  - Waiting : 프로세스가 어떤 이벤트를 기다리거나, 특정 자원의 사용이 가능할 때 까지 대기
  - Terminated : 프로세스 실행 종료. 자원 해제
- :star::star:Multi thread를 설명하시오
  - thread는 한 프로세스 내에서 실행하는 기능의 단위. 각 thread는 속한 process의 stack을 제외한 나머지 영역 공유
  - Multi Thread는 하나의 프로세스가 여러 작업을 병렬로 처리하기 위해 사용. 각자 stack 영역을 가짐.
- thread는 왜 독립적인 stack memory 영역이 필요한가요?
  - 각 스레드가 독립적으로 함수를 실행하기 위해선 복귀 주소, 지역 변수 를 저장하기 위한 독립적인 저장 공간이 필요하기 때문입니다. 
  - 또한 멀티 스레드 환경에서는 프로세스 내에서 스레드 컨텍스트 스위칭이 일어나게 되므로 각 스레드마다 프로세스의 코드 영역에 코드 주소를 저장합니다.
- process와 thread 비교 설명
  - 프로세스는 코드가 메모리에 적재되어 CPU에 의해 실행된 하나의 프로그램입니다. 
  - 쓰레드는 프로세스 내에서 독립적, 병렬적으로 실행되는 기능의 단위를 의미합니다. 
  - 따라서 쓰레드는 프로세스 내의 Stack영역을 제외한 메모리 영역을 공유하여 사용합니다.
- :star::star:Multi process와 Multi thread를 비교설명 하시오
  - 멀티 스레드가 좋은 점
    - 적은 메모리 공간, 컨텍스트 스위칭이 빠름
    - 스레드간 통신 비용이 프로세스 통신 비용보다 적기 때문에 오버헤드가 적음
  - 멀티 스레드가 안좋은점
    - 동기화 문제, 하나의 스레드에 장애 발생시 전체 스레드가 종료될 위험이 있음
    - 프로세스는 하나의 프로세스에 장애가 발생해도 다른 프로세스에 영향 X
- :star::star:Multi process 환경에서 process간에 데이터를 주고받는 방식을 설명하시오
  - IPC를 통해 통신이 가능
- IPC의 예시? 파이프, 파일, 소켓, 공유 메모리
- `공유 메모리`와 `메시지 전달 모델`의 장단점
  - 공유 메모리 방식 : 주소 공간의 일부 공유. 커널에 의해 공유 메모리 영역을 구축하며, 한번 구축된 이후에는 커널의 관여 없이 통신이 가능해 속도가 빠름. 그러나 일관성 문제 발생 가능
  - 메시지 전달 방식 : 커널을 통해 send, receive 연산 제공 받음. 공유 메모리보단 느리지만 충돌을 회피할 필요가 없음. 
    - 익명 파이프 : 부모 자식간에 가능한 단방향 방식으로 데이터 전달
    - 명명된 파이프 : 파이프 서버와 클라이언트 간의 통신 (?)
    - socket(TCP, UDP)
    - message queue : 메시지를 큐 데이터 구조 형태로 관리. 커널에서 전역적으로 관리
- :star: Multi process/thread 환경에서 동기화 문제의 해결방안을 설명하시오
  - mutex : 1개의 스레드만이 공유자원에 접근하여, 하나의 스레드가 자원에 lock을 걸면 다른 스레드는 unlock이될 때까지 접근 불가
  - semaphore :여러개의 스레드만이 공유 자원에 접근. 세마포 값을 사용 가능한 자원의 수로 초기화 하여, 자원을 사용하면 값을 감소하고 해제하면 증가시키면서 정해진 세마포 값 만큼의 프로세스만 공유 자원에 접근 가능
- 교착상태(Deadlock)를 설명하시오
  - 둘 이상의 스레드가 서로의 점유한 자원을 기다릴 때 무한 대기 상황에 빠진다.
  - 조건 : 
    - 상호배제 : 자원을 한 스레드만 점유 가능
    - 점유대기 : 자원을 보유한 상태에서 다른 스레드가 보유한 자원을 기다림
    - 비선점 : 다른 스레드가 상요중인 자원을 강제로 선점 불가
    - 순환대기 : 순환 형태로 스레드간 자원 대기
  - 해결 : 
    - 무시 : 데드락 무시
    - 예방 : 4가지 조건 중 하나가 성립하지 않도록 함 (효율성 떨어짐)
    - 회피 : 스레드가 앞으로 필요한 자원에 대한 정보를 통해 순환 대기 방지
      - 자원 할당 그래프 알고리즘, 은행원 알고리즘(너가 원하는거랑 내가 가진거 비교)
    - 탐지-회복 : 시스템 검사를 통해 데드락 발생을 탐지, 회복
- paging을 설명하시오
  - 프로세스의 메모리 공간을 동일한 크기의 page로 나누어 메모리를 관리한다.
  - 물리적 주소가 연속적이지 않더라도 주소 바인딩을 통해 논리적 주소와 물리적 주소를 연결짓는다.
- paging 기법 사용시 발생할 수 있는 메모리 단편화 문제에 대해 설명
  - 외부 단편화 : 프로세스들이 할당된 메모리 공간 사이에 작은 조각이 남는 경우.
  - 내부 단편화 : 프로세스가 필요한 메모리 공간보다 페이지 크기가 큰 경우, 페이지 내에 남는 공간이 발생하여 낭비됨.
- segmentation을 설명하시오
  - code, data, stack등 의미를 기준으로 메모리 공간을 나누는 방법
  - 크기가 균일하지 않기 때문에, segment의 번호와 offset을 저장하고, segment table은 세그먼트 **길이**를 담은 변수가 존재한다.
- segmentation의 메모리 단편화 문제에 대해 설명
  - 외부 단편화 : 세그먼트 크기가 동적으로 결정되기 때문에, 메모리에 할당, 해제될 때 외부 작은 조각들이 남음
  - 내부 단편화 : 세그먼트 크기가 동적으로 결정되기 때문에, 할당된 공간의 크기보다 실제 필요한 공간의 크기가 작을 수 잇음
- paging과 segmentation의 차이
  - paging은 고정된 크기로 메모리 공간을 분할하고, segmentation은 의미 단위로 분할하여 동적으로 크기가 결정된다.
- paged segmentation 기법?
  - 프로세스를 논리적 세그먼트로 나누고, 각 세그먼트 내에서 페이지 단위로 나눔. 논리적 구조를 유지하며 세그먼트를 페이지로 나눔으로써 내부 단편화를 줄일 수 있음
- :star:가상 메모리를 설명하시오
  - 프로세스 전체가 메모리에 올라오지 않더라도 실행이 가능하도록 하는 기법
  - 필요한 부분만 물리적 메모리에 적재, 직접적으로 필요하지 않은 공간은 swap에 저장
- 요구 페이징이란 무엇?
  - 당장 사용될 주소 공간을 page 단위로 메모리에 적재하는 방법
  - 메모리 사용량 감소, 오버헤드 감소
- page fault
  - CPU가 물리적 메모리에 올라와있지 않은 page에 접근하는 상황
  - MMU가 page fault trap 발생시키고, 디스크에서 해당 페이지를 물리적 메모리의 빈 프레임에 적재하고, page 테이블 업데이트
- 페이지 교체 알고리즘에 대해 아는대로 설명
  - page fault가 발생하여 해당 page를 가져와야하는데 물리적 메모리 공간이 부족한 경우 교체를 해야함 어떤 page를 교체할지 고르는 알고리즘
  - FIFO : 메모리에 올라온지 가장 오래된 page 교체
  - 최적 페이지 교체 : 앞으로 가장 오랫동안 사용되지 않을 page를 찾아 교체. 실제 구현 X 비교 기준
  - LRU : Least Recently Used  가장 사용된지 오래된 페이지를 교체
  - LFU : Least Frequently Used 가장 적게 사용된 페이지를 교체
- LRU와 LFU 알고리즘 비교 설명
  - LRU = Least Recently Used
    - 메모리에서 가장 **오랫동안 사용되지 않은** 페이지를 선택하여 교체
    - **링크드 리스트** 형태로관리하여 최근 참조된 페이지를 가장 밑단으로 보낸다.
    - 현재 가장 이상적인 방법
  - LFU = Least Frequently Used
    - 메모리에서 가장 **적게 참조한** 페이지를 선택하여 교체
    - 모든 페이지를 비교해야하기 때문에 **최소 Heap**으로 관리한다.
    - LRU처럼 직전만 보는게 아니라 전체를 보기 때문에 **Page의 인기도 확인 가능(모니터링 가능)**
  - OS는 disk에 접근하는 I/O 작업이 일어났을 때 관여하기 때문에 이미 물리적인 메모리에 올라와있는 페이지에 접근하는 것에 대한 정보를 얻기 어렵다. LRU, LFU는 실질적으로 사용하기 불가능하다.

