# Database

- Index란 무엇인지

  - 검색 성능을 높여주는 대표적인 방법 중 하나입니다. RDBMS는 B+Tree구조로 된 Index를 사용하여 검색 속도를 향상시킵니다.
  - **특정 column의 값(search key)을 기준으로 정렬**하여 **데이터의 물리적 위치(pointer)**와 함께 별도 파일에 저장합니다.
  - 순서대로 정렬된 search-key 값과 pointer만 저장하기 때문에 table보다 적은 공간을 차지합니다.
  - 대신 table 크기의 약 10% 크기의 추가 저장 공간이 필요하며, 데이터 변경이 잦을 경우 B+Tree의 구조가 변경될 수 있기 때문에 성능이 나빠질 수 있습니다.

- index의 필요성을 설명하시오

  - 검색 속도 향상을 위해 필요합니다. 특정 column에 대한 Index를 생성할 경우, 해당 속성에 대해 정렬되어 저장되어있기 때문에 Full table scan할 필요 없이 조건 검색 속도가 굉장히 빠릅니다.

- :star::star::star::star:index를 어느 column에 사용하는 것이 좋을지 설명하시오

  -  where 절에서 **자주 조회되고** + **수정 빈도가 낮으며** + **카디널리티가 높고(중복이 적고)** + **선택도가 낮은** 컬럼에 적합합니다.
    - Join은 두 테이블에서 일치하는 값을 찾아야 하므로, 많은 시간이 소요됩니다. 그러나 인덱스가 설정되어있다면 훨씬 빠르게 일치하는 레코드를 찾을 수 있습니다. 인덱스가 설정된 컬럼을 기준으로 join 연산을 수행하는 것은 보통 더 효과적입니다.
    - 데이터를 수정할 때마다 Index는 정렬을 다시 해야하므로 부하가 발생합니다.
    - 카디널리티(데이터 집합의 유니크한 값의 수)가 낮으면, (= 선택도(한 번의 조회 쿼리에 해당하는 레코드가 얼마나 존재하는지)가 높으면) 해당 인덱스가 가리키는 모든 레코드에 대해 다시 검색해야합니다. 여전히 많은 수의 데이터를 처리해야하므로, 검색 시간 단축에 효과가 없습니다.

  - 성별 컬럼에 index를 걸어주면 좋을까요?
    - 인덱스의 검색 효율은 데이터의 고유성에 크게 의존합니다. 카디널리티가 낮으면 인덱스는 레코드를 명확하게 구분하는데 별로 도움이 되지 않습니다. '남성' 값에 인덱스를 찾아도 여전히 많은 '남성'레코드를 모두 검색해야하기 때문입니다.

  - true, false 값을 갖는 컬럼에서 true 1%, false 99% 의 비율인 경우 index를 거는게 좋을까요?
    - false값의 선택도가 너무 높기 때문에 효율적이지 않습니다. 결국 false에 대해 검색할 경우, 인덱스를 거쳐가는 과정이 추가적인 오버헤드를 발생시키기 때문에 오히려 Full Scan보다 성능이 떨어질 수 있습니다.
  - Index를 쓰면 성능이 좋아지니까 모든 컬럼에 인덱스를 사용하면 성능이 더 좋겠네요?
    - index 생성은 테이블에 추가적인 오버헤드를 부과하고 디스크 공간을 차지하기 때문에, 필요한 인덱스만 생성해야합니다. 또한, 데이터를 수정하면 index는 매번 정렬을 다시해야합니다. 한 테이블에 index가 너무 많으면 데이터 수정시 소요되는 시간이 너무 길어질 수 있습니다.

- :star:데이터를 검색할 때, hash table의 시간복잡도는 O(1)이고, b+tree는 O(logN)으로 더 느리다. 왜 Index는 HashTable이 아니라 b+Tree로 구현되는지 설명하시오

  - HashTable을 사용하면 **하나의 데이터**를 탐색하는 시간은 O(1)로 B+Tree보다 빠르지만
  - 값이 정렬되어있지 않기 때문에 **부등호를 사용**하는 쿼리에 대해서는 O(N)의 시간으로 전체 요소를 검색해야하기 때문에 데이터를 정렬하는 B+Tree 구조를 사용합니다.
  - 또한 B+Tree는 리프노트가 연결리스트로 연결되어있어 범위 검색에 유리합니다.

- :star::star:Transaction을 설명하시오

  - DB 내에서 수행되는 최소 작업 단위이며, DB의 무결성을 유지하고 상태를 변화시키는 역할을 합니다. 장애 발생시 데이터를 복구하는 작업의 단위가 됩니다.
  - 하나 이상의 쿼리를 포함해야하고, 원자성, 일관성, 고립성, 지속성의 규칙을 만족해야합니다.
    - 원자성 : 트랜잭션에 포함된 작업은 전부 수행되거나, 전부 수행되지 말아야 합니다.
    - 일관성 : 허용된 방식으로만 데이터를 변경해야한다.
    - 고립성 : 다른 트랜잭션의 연산 작업에 끼어들 수 없습니다.
      - 동시성제어 : 수정 중에 있는 트랜잭션은 해당 데이터를 다른 트랜잭션이 접근하지 못하도록 잠급니다. Lock이 걸린 데이터는 Unlock이 될 때까지 다른 트랜잭션들이 대기해야합니다.
    - 지속성 : 트랜잭션을 성공적으로 완료하면 DB에 영원히 반영되어야합니다.
  - COMMIT : 트랜잭션으로 변경된 내용이 모두 영구적으로 저장되는 것
  - ROLLBACK : 트랜잭션을 수행하기 전으로 되돌리는 것
  - => 데이터 무결성 보장. 데이터 무결성 = 정확성, 일관성, 유효성 유지
    - 개체 무결성 : PK는 빈값 X
    - 참조 무결성 : 참조 관계의 테이블은 항상 일관된 값 유지
    - 고유 무결성 : 특정 속성에 대해 고유한 값
    - NULL 무결성 : NULL X

- :star: DeadLock을 설명하시오

  - 여러 트랜잭션이 각각 자신의 데이터에 대해 LOCK을 획득한 상태에서 상대방 데이터 접근하고자 대기할 때, 서로 영원히 기다리는 상태를 말합니다.
  - Deadlock을 해결하려면?
    - 각 트랜잭션이 실행되기 전에 필요한 데이터를 한번에 요청합니다.
    - 자원 할당시 데드락으로 이어질 가능성이 있다면 할당을 보류합니다. 자원 할당 상태와 트랜잭션의 자원 요청 정보를 실시간으로 관리해야합니다.
    - deadlock이 발생하면 이를 감지하고 회복시킵니다. 데드락을 정기적으로 탐지하고 데드락 발생시 롤백등의 조치를 취합니다.

- :star: RDB VS NoSQL을 비교설명하시오

  - 관계형 데이터 베이스는 행과 열을 가지는 테이블 형식으로 데이터를 저장하는 데이터베이스입니다.
  - NoSQL은 테이블이 아닌 키-값 쌍, Json, 그래프 등의 형태로 데이터를 저장하는 데이터베이스입니다.
  - RDB는 정형화된 데이터를 처리하는데 적합하며, NoSQL은 다양한 형태의 데이터를 쉽게 저장하고 처리하는데 적합합니다.
  - RDB는 ACID 트랜잭션을 지원하며 데이터의 일관성을 보장합니다. NoSQL은 일관성을 다소 희생하더라도 확장성, 성능을 우선합니다.
  - RDB는 데이터 구조가 변경될 여지가 없고, update가 잦은 경우에 적합합니다.
  - NoSQL은 데이터의 구조가 정확히 정해지지 않고, 수정보다 조회가 많은 경우, 또는 데이터 양이 많은 경우 scale-out이 가능하기 때문에 적합합니다.
    - NoSQL은 수평확장을 위해 설계된 데이터베이스라 scale-out에 효과적이다.
      1. 분산처리 : 여러 서버에 데이터 분산 저장, 동시에 여러 작업 처리 가능
      2. 데이터 복제 지원
      3. 스키마 유연성 : 데이터 구조 변화에 대한 비용이 적다.
      4. 빠른 응답 시간 : 빠른 조회에 최적화
    - 데이터 양이 늘어나거나, 요청이 증가함에 따라 서버를 추가하기만 하면 된다.

- Primary key를 설명하시오

  - 각 row를 유일하게 구분하는 컬럼을 말합니다. 중복된 값, NULL값을 가질 수 없습니다. 기본키는 테이블 당 1개만 지정해야 합니다.
  - 슈퍼키 : 각 ROW를 유일하게 식별할 수 있는 속성 (유일성)                           
  - 후보키 : 각 ROW를 유일하게 식별할 수 있는 최소한의 속성 (유일성 + 최소성)
  - 대체키 : 후보키가 2개 이상일 경우, 기본키를 제외한 후보키들
  - 외래키 : 다른 테이블의 기본 키를 그대로 참조하는 값. 테이블 간의 관계를 식별하는데 사용합니다.
  - 복합키 : 2개 이상의 컬럼을 결합하여 각 ROW를 유일하게 구분하는 후보키

- 관계형 데이터베이스의 N:M 관계를 설명하시오

  - 양쪽 엔티티 모두가 서로에게 1:N 관계를 지닌 구조입니다.
  - Mapping table을 통해 관계를 맺는다.
  - `1:N` : 하나의 테이블이 관계를 맺은 테이블의 '여러' 객체를 가질 수 있는 구조

- left outer join, inner join의 차이를 설명하시오

  - Join이란 두개 이상의 테이블을 연결하여 하나의 테이블을 결과로 만들어내는 것입니다.
  - inner join은 join한 테이블들에 공통적으로 포함된 내용만 join 합니다.
  - left outer join은 왼쪽 테이블의 모든 행에 대해 join합니다.





+) 궁금증

- mysql의 클러스터 인덱스를 설정하는게 어떤 점에서 좋은가요?? 그렇다면 pk를 조회할 때 인덱스가 설정되어있지 않다면 DB를 full scan 하나요? 그렇다면 모든 테이블에 클러스터 인덱스를 설정하는게 좋은가요?

  - 클러스터 인덱스는 특정 방식으로 데이터베이스 내 데이터를 **물리적으로 재정렬**합니다. MySQL에서 InnoDB 스토리지 엔진을 사용하는 경우, **기본 키(Primary Key, PK)는 클러스터 인덱스로 자동 설정**됩니다. 클러스터 인덱스의 장점은 다음과 같습니다:

    1. 데이터 접근 속도: 클러스터 인덱스는 테이블의 데이터를 인덱스 키 순서대로 물리적으로 재정렬합니다. 이는 해당 키를 기준으로 데이터를 검색할 때 빠른 속도를 제공합니다.
    2. 범위 쿼리의 성능 향상: 인덱스 키의 값이 연속적인 범위로 검색되는 경우, **클러스터 인덱스는 해당 범위의 모든 값이 물리적으로 가까운 곳에 위치**하므로 이러한 쿼리의 성능을 크게 향상시킵니다.
    3. 데이터의 정렬: 클러스터 인덱스는 테이블의 데이터를 특정 순서로 유지합니다. 이는 정렬된 데이터를 필요로 하는 쿼리에 유용합니다.

    그러나 PK에 클러스터 인덱스가 설정되어 있지 않다면, 데이터를 찾기 위해 테이블 전체를 스캔해야 할 수 있습니다. 이는 성능에 부담을 줄 수 있습니다.

    그럼에도 불구하고, 모든 테이블에 클러스터 인덱스를 설정하는 것이 항상 좋은 것은 아닙니다. 클러스터 인덱스는 데이터를 물리적으로 재정렬하기 때문에, 데이터의 삽입, 삭제, 업데이트가 발생할 때마다 해당 작업을 수행해야 합니다. 이는 성능에 부담을 줄 수 있습니다. 따라서 테이블의 사용 패턴, 쿼리의 특성 등을 고려하여 인덱스를 결정하는 것이 중요합니다.























---

# 네트워크

- OSI 7계층과 TCP/IP 4계층을 비교 설명하시오
  - OSI 7계층은 네트워크 통신을 표준화한 모델로 통신 시스템을 7단계로 나눈 것이고, TCP/IP는 실제 인터넷에 구현된 구조로 나눈것입니다.
  - OSI 7계층은 물리, 데이터 링크, 네트워크, 전송, 세션, 표현, 응용 레이어로 나뉩니다.
  - TCP/IP 4계층은 네트워크 인터페이스, 네트워크, 전송, 응용 레이어로 나뉩니다.
- :star:TCP vs UDP를 비교 설명하시오
  - TCP는 연결형, 신뢰성 전송 프로토콜. 3-way-handshake로 연결을 설립. 신뢰성 보장을 위해 
  - UDP는 단순한 방식으로 데이터를 전송하기 때문에 신뢰성이 낮다. 스트리밍과 같이 중간에 데이터가 손실되어도 괜찮은 경우에 사용함.
- 3-way handshake는 무엇이고 각 과정은 어떻게 되는지 설명하시오
  - 3-way-handshake는 클라이언트가 서버에 HTTP 요청을 보내기 위해 TCP 연결을 시도하는 과정에서 연결이 수립되는 과정을 의미합니다.
  - 우선 클라이언트에서 연결 요청을 위해 SYN 패킷을 보냅니다. 서버는 SYN 패킷을 받고, 다시 SYN 패킷과 함께 연결을 수락하는 ACK 패킷을 보냅니다. 이후 클라이언트가 다시 연결 수립을 승낙하는 ACK를 서버로 보내면 TCP 연결이 수립됩니다.
- 4-way-handshaking
  - 클라이언트가 세션 종료를 위해 FIN 패킷 보냄
  - 서버가 ACK 패킷 보내고 프로세스 종료를 기다림. 
  - 서버에서 프로세스가 종료되면 FIN 패킷을 클라이언트에 보냄.
  - FIN 패킷을 받은 클라이언트가 서버에 ACK 패킷을 보냄.
  - 서버가 ACK를 받으면 연결 종료.
- HTTP를 설명하시오
  - HyperText Transport Protocol
  - 서버-클라이언트 모델을 따르며 요청-응답 구조로 웹 상에서 정보를 주고받는 프로토
  - Connectionless : 요청에 대한 응답을 받으면 연결을 끊음으로써 많은 사람이 웹을 이용하더라도 동시 접속을 최소화하여 최대한 많은 요청 처리
  - Statless : 그러나 Connectionless로 인해, 클라이언트의 이전 상태를 알 수 없다는 특징. 이를 극복하기 위해 cookie, session, jwt 활용
- :star::star:HTTP Request Method중 GET vs POST를 비교 설명하시오
  - GET : 클라이언트가 서버에 데이터를 요청할 때 사용하며 url 주소 끝에 key-value 쌍으로 쿼리 스트링을 만들어 전송. 캐싱이 가능하여 요청한 적이 있는 결과를 브라우저가 저장하고 재사용 가능
  - POST : 클라이언트가 서버에 데이터를 전달할 때 사용하며, body에 필요한 데이터를 담아서 전달함. 
  - PUT : 특정 자원을 전부 수정할 때
  - PATCH : 특정 자원의 일부를 수정할 때
- HTTP Status Code를 설명하시오
  - 클라이언트 요청에 대한 서버의 응답 코드로, 상태 코드를 통해 요청의 처리 결과를 알 수 있습니다. 100번대 부터 500번대 까지 총 5개의 클래스로 구분.
    - 100 : 요청 받았으며 작업 계속
    - 200 : 성공
    - 300 : redirect
    - 400 : 실패 (잘못된 요청)
    - 500 : 실패 (서버 에러)
- :star::star:`www.google.com`을 주소창에 입력시, 화면이 나오기까지의 과정을 네트워크 관점으로 설명하시오
  - 입력받은 url이 도메인인지 확인. 요청을 보내기 위해선 해당 서버의 IP 주소가 필요하다.
  - 먼저 브라우저에서 DNS 캐시를 확인하고 없다면 OS의 host 파일을, 공유기의 캐시도 확인한다. 공유기에서도 못 찾는다면 이제 ISP를 통해 DNS 질의를 요청한다. 
  - 도메인에 해당하는 아이피를 알았다면, HTTP 요청을 위해 TCP 요청을 보낸다. 3-way-handshake과정을 거쳐 해당 서버와 연결을 수립한다. 
  - 연결이 된 상태에서 HTTP 요청을 보내고, 응답을 받는다. 받은 HTTP 응답을 HTML, Javascript, CSS로 파싱하여 브라우저에 렌더링 한다.
  - 서버와의 연결을 종료할 땐 4-way-handshake로 서버와의 연결을 끊는다.
- :star:쿠키와 세션의 차이점을 설명하시오
  - 쿠키는 클라이언트에 저장되고, 세션은 서버에 저장된다는 차이가 있습니다.
  - 쿠키는 로컬 PC에 저장된다는 점에서 속도는 빠르지만 보안에 취약합니다.
  - 세션은 서버에서 조회하기 때문에 쿠키보다는 속도가 느리지만 보안성이 우수합니다.
  - 클라이언트가 서버에 요청을 보내고, 서버가 쿠키를 생성해서 HTTP 응답에 포함하여 클라이언트에 전달합니다. 이후 클라이언트는 로컬 PC에 저장된 쿠키의 정보를 요청에 담아 서버에 보낼 수 있습니다.
  - 클라이언트가 서버에 요청을 보내고, 서버는 쿠키를 확인하여 클라이언트가 session-id를 보냈는지 확인합니다. session-id가 존재하지 않는다면 서버는 생성하여 클라이언트에게 응답합니다. 
- 세션이 보안도 좋은데 쿠키를 사용하는 이유는?
  - 세션이 보안이 좋지만 서버에 데이터를 저장한다는 점에서 서버의 자원 사용하기 때문에 서버에 부하를 준다.
  - 쿠키와 세션을 적절하게 병행 사용하여 서버의 자원 낭비를 방지하고 속도를 높인다.
- 쿠키의 사용 예시
  - 로그인, 장바구니, 테마, 광고 개인화를 위한 트래킹
- 쿠키와 세션을 이용한 로그인 방식을 화이트보드에 설명하시오
  - 클라이언트가 로그인을 하면 서버는 회원 정보를 대조하고, 회원 정보 세션을 session storage에 저장한다. 
  - 응답에 session-id를 포함하여 클라이언트에게 전달한다.
  - 이후 클라이언트는 서버에 요청할 때 session-id를 포함하여 요청을 보내게 된다.
  - 서버는 session storage의 정보와 대조하고 클라이언트 정보를 바탕으로 응답을 전달한다.
    -  세션 하이재킹을 방지하기 위해 session 만료시간을 설정하거나 HTTPS를 사용한다.
- url과 uri의 차이
  - url : uri의 하위 집합으로, 리소스의 '위치'를 지정. 
  - uri : 웹 리소스를 고유하게 식별하는 식별자.