# 상속

```java
class Parent {
    int age;
    void saySomething() {
        System.out.println("부모 클래스");
    }
}

class Child extends Parent {
    int name;
    
    void saySomething() {
        System.out.println("자식 클래스");
    }
}
```



```java
Child c = new Parent(); // 불가능함. 에러
Child c = new Child();

Parent p = new Parent();
Parent p = new Child();
```

- `Child c = new Parent()` 는 불가능한 코드. 컴파일 에러

- `Parent p = new Child()` 는 **upcasting**의 경우이고, p는 Child 클래스의 메서드나 속성에 접근할 수 없음. 
- **downcasting**을 통해 Child의 속성, 메서드를 사용할 수 있음 `((Child)p).childClassMethod();`



## Q. upcasting이 필요한 경우?

> 다형성 => 같은 메서드 호출이지만 참조하는 객체의 타입에 따라 다른 동작을 수행할 수 있게 됩니다.

```java
Parent p1 = new Child1();
Parent p2 = new Child2();

p1.doSomething(); // Child1's doSomething()
p2.doSomething(); // Child2's doSomething()
```

Child1과 Child2 에서 `doSomething()` 을 다르게 구현했다면, 같은 메서드 호출이지만 객체의 실제 타입에 따라 다르게 동작함.



- `Child1 c1 = new Child1()` 랑 `Child2 c2 = new Child2()` 로 해도 되지 않는가?

- `Child1 c1 = new Child1();`와 `Child2 c2 = new Child2();`로 선언하게 되면, `c1`과 `c2`는 각각 `Child1`과 `Child2` 타입의 참조 변수가 됩니다. 이 경우 `c1`과 `c2`는 각각의 클래스에 선언된 모든 메서드와 속성에 접근할 수 있습니다.

  반면에 `Parent p1 = new Child1();`와 `Parent p2 = new Child2();`로 선언하게 되면, `p1`과 `p2`는 `Parent` 타입의 참조 변수가 되며, `Parent` 클래스에 선언된 메서드와 속성에만 접근할 수 있게 됩니다.

  그럼에도 불구하고 왜 후자를 선택할까요? **이는 다형성이라는 객체지향 프로그래밍의 핵심 원칙 때문입니다.** 이를 통해 코드를 더 유연하고 확장 가능하게 만들 수 있습니다. 예를 들어, 여러 하위 클래스가 같은 상위 클래스를 상속받고 있을 때, 상위 클래스 타입의 변수를 사용하면 하위 클래스의 구체적인 타입에 상관없이 코드를 작성할 수 있습니다.

  ```java
  Parent[] parents = new Parent[2];
  parents[0] = new Child1();
  parents[1] = new Child2();
  
  for (Parent p : parents) {
      p.doSomething(); // Child1과 Child2가 doSomething을 오버라이딩 했다면, 각 하위 클래스의 메서드가 실행됨
  }
  ```

  이런 식으로 작성된 코드는 `Child1`과 `Child2` 외에 새로운 하위 클래스가 추가되더라도 그대로 동작하며, 이는 코드의 유지 관리가 더 쉬워짐을 의미합니다. 따라서 상황에 따라 `Parent p = new Child();` 형태의 코드가 더 적합할 수 있습니다.



## Q. `@Override` 없이 오버라이딩?

> 필수는 아니지만 코드의 가독성과 오류를 방지하는데에 있어서 좋다.

Java에서는 부모 클래스의 메서드를 자식 클래스에서 재정의하거나 "오버라이드" 할 때, `@Override` 어노테이션을 사용하는 것이 권장되지만 **필수는 아닙니다.** 

`@Override` 어노테이션은 컴파일러에게 이 메서드가 부모 클래스의 메서드를 오버라이드하는 것임을 명시적으로 알려줍니다. 이를 통해 컴파일러는 실수로 메서드 시그니처를 잘못 입력하여 실제로는 오버라이드가 이루어지지 않았을 때, 그것을 오류로 잡아낼 수 있습니다. 따라서 `@Override` 어노테이션은 **프로그래머의 실수를 방지**하는 역할을 합니다.

예를 들어, 부모 클래스의 `doSomething()` 메서드를 오버라이드하려고 하지만 실수로 `doSometing()` (마지막 'h'가 빠짐)라고 썼다고 가정해봅시다. 이 경우 `@Override` 어노테이션을 사용하면 컴파일러는 `doSometing()` 메서드가 부모 클래스에 없다는 것을 알려주어 실수를 바로잡을 수 있게 합니다. 반면, `@Override` 어노테이션을 사용하지 않으면 컴파일러는 이를 새로운 메서드로 인식하고 아무런 오류를 띄우지 않습니다. 따라서 원하던 대로 코드가 동작하지 않을 수 있습니다.

```java
class Parent {
    void doSomething() {
        System.out.println("부모 클래스");
    }
}

class Child extends Parent {
    // 오타로 g가 빠졌는데 알 수 없음. 오버라이드가 아닌 그냥 새로운 함수
    void doSomethin() {
        System.out.println("자식 클래스");
    }
    
    // doSomething이 아니기 때문에 부모에 doSomethin 따윈 없다고 알려줌
    @Override
    void doSomethin() {
        System.out.println("자식 클래스");
    }
}
```



따라서 `@Override` 어노테이션을 사용하면 의도하지 않은 실수를 방지하고 코드의 가독성을 높이는 데 도움이 됩니다. 그럼에도 불구하고 `@Override`를 사용하지 않아도 컴파일과 실행 자체에는 문제가 없습니다. 오버라이드를 하는 메서드라는 것을 명확히 나타내고 싶지 않거나, 간혹 특정 상황에서 어노테이션을 생략하고자 할 때 `@Override`를 사용하지 않을 수 있습니다. 그러나 이는 일반적으로 권장되지 않는 방식입니다.



# 상속 vs 합성

