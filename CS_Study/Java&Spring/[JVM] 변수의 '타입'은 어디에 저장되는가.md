# 변수의 '타입'은 어디에 저장되는가?

변수의 타입이 어디에 저장되는지 궁금해졌다. JVM의 Runtime Data Area의 Method Area나 Stack에 메서드 Frame에 저장된 다는 말은 봤는데, 그렇다면 컴파일 때는 확인 못하고 런타임 때 문제가 발생하는 이유가 무엇인지, 힙에 저장된 객체의 인스턴스를 확인한다는 말과는 무슨 차이가 있는지 이해하기 어려웠다.

그 이유는 **변수의 타입**과 **실제 값의 타입**을 구분해서 생각하지 못 했기 때문이다.

- 정적으로 선언된 타입과 동적으로 결정되는 객체의 실제 타입 사이의 차이로 인해 런타임에 타입으로 인한 문제가 발생할 수 있습니다. 
- 컴파일러는 변수의 선언된 타입을 알고 있지만, 이를 실행 중에 변수가 참조하는 객체의 실제 타입과 혼동하지 않습니다. 변수가 참조하는 객체의 실제 타입은 런타임에 결정되고, 이 정보는 변수가 가리키는 메모리 주소에 저장됩니다. 변수 자체는 객체의 실제 타입을 직접 저장하지 않습니다.

## 변수의 타입 != 실제 값의 타입

변수의 타입과 그 변수가 가리키는 값(또는 저장하는 값)의 타입은 별개입니다.

### 변수의 타입

- 변수의 타입은 해당 변수가 선언될 때 컴파일 시간에 결정됩니다. 이 정보는 컴파일된 코드에 포함됩니다. 변수의 선언된 타입은 컴파일러가 그 변수가 어떤 종류의 데이터를 저장할 수 있는지를 확인하는 데 사용됩니다.
- 예를 들어, `int x;`에서 변수 `x`의 타입은 `int`입니다. 이는 해당 변수가 정수값을 저장할 수 있다는 것을 나타냅니다.

### 변수가 가리키는 값(또는 저장하는 값)의 타입

- 변수가 참조하는 객체나 저장하는 값의 타입은 해당 값 자체가 가진 타입입니다. 변수가 참조하는 객체의 실제 타입이 런타임에 결정됩니다.
- 예를 들어, 객체를 가리키는 참조 변수의 경우, 변수가 참조하는 객체의 타입은 해당 객체의 클래스입니다. 변수의 타입과 객체의 타입이 일치할 수도, 상속 관계에 있을 수도 있습니다.

메서드 영역(Method Area)에는 클래스의 구조 정보, 필드의 타입 정보 등이 저장됩니다. 로컬 변수 배열(Local Variables Array)에는 각 메서드 실행 중에 사용되는 로컬 변수들의 값들이 저장되며, 이 값들은 해당 변수가 가리키는 객체의 실제 타입을 나타내는 정보일 수 있습니다. 변수의 값(또는 참조하는 값)의 타입은 해당 값 자체의 타입을 나타냅니다.



## 인스턴스를 매번 확인하는가?

`Parent x = new Child();`의 경우 `x`는 `Parent` 타입의 변수이지만 실제로 참조하고 있는 객체는 `Child` 클래스의 인스턴스입니다. 변수 `x`는 `Parent` 타입으로 선언되어 있으므로 컴파일러는 `Parent` 클래스의 메서드와 변수에만 접근을 허용합니다.

그러나 런타임 시에는 변수 `x`가 실제로 참조하는 객체가 `Child` 클래스의 인스턴스이기 때문에, `x.method()`를 호출할 때는 해당 메서드가 `Child` 클래스에 오버라이딩(재정의) 되었는지를 확인합니다. 만약 메서드가 `Child` 클래스에서 오버라이딩 되었다면, 실제로는 `Child` 클래스의 메서드가 실행됩니다. 이는 자바의 다형성(polymorphism) 개념으로, 런타임에 객체의 실제 타입을 확인하여 메서드 호출을 결정합니다.

따라서 `x.method()`를 여러 번 호출하더라도 매번 해당 메서드가 `Child` 클래스에 오버라이딩되었는지를 확인하고, 필요한 경우 실제 객체의 타입에 맞는 메서드를 실행하게 됩니다.



## Primitive Type vs Reference Type

원시 타입 = 값 자체에 저장되어있음

참조 타입 = 힙에서 확인해야됨

- Primitive Type을 가진 변수는 해당 값을 직접 저장하기 때문에 참조 변수가 아니며, 컴파일러는 Primitive Type 변수를 다룰 때 타입을 확인하지 않습니다. 이러한 변수들은 실제 값 자체를 저장하므로 타입 확인이 필요하지 않습니다. 대신, 해당 변수가 선언된 타입의 크기와 종류에 따라 해당 값을 저장하고 처리합니다.
  - 예를 들어, `int`, `double`, `boolean`과 같은 기본 데이터 타입은 해당 값을 직접 저장하므로 컴파일러는 이들을 직접적으로 다룹니다. 따라서 이러한 변수들은 참조 변수가 아니며, 참조하는 객체의 실제 타입을 확인하는 과정이 필요하지 않습니다. 변수가 이미 값을 포함하고 있기 때문에 별도의 타입 확인이 필요 없습니다.