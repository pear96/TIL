# 상속 vs 합성

[Inpa Dev 👨‍💻:티스토리](https://inpa.tistory.com/entry/OOP-💠-객체-지향의-상속-문제점과-합성Composition-이해하기 )

상속과 합성은 OOP에서 가장 널리 사용되는 코드 재사용 기법이다.

|      | 상속                                                | 합성                                              |
| ---- | --------------------------------------------------- | ------------------------------------------------- |
|      | 컴파일                                              | 런타임                                            |
|      | is-a                                                | has-a                                             |
|      | 부모 클래스의 구현에 의존 결합도가 높음             | 인터페이스에 의존하기 때문에 구현에 의존하지 않음 |
|      | 클래스 사이의 정적인 관계                           | 객체 사이의 동적인 관계                           |
|      | 부모 클래스 안에 구현된 코드 자체를 물려받아 재사용 | 포함되는 객체의 퍼블릭 인터페이스를 재사용        |



## 상속

부모 클래스의 자원을 물려받으며, 다른 부분만 추가하거나 재정의하기 때문에 쉽게 확장할 수 있다.

하지만 **좀 더 구체적인 클래스 구현**이라는 목적에 초점을 맞추는 것이 좋다. 따라서 명확한 is-a 관계에 있는 경우, 상위 클래스가 확장될 목적으로 설계된 경우 사용하면 좋다.

상속은 부모 클래스 내부 구현에 대해 상세히 알아야하기 때문에 자식과 부모의 결합도가 높을 수 밖에 없고, 코드를 실행하는 도중에 바꿀 수 없다.(정적)

JDK 8부터는 인터페이스 디폴트 메서드로 인터페이스 내에서 로직 구현이 가능해져 상속의 장점이 약화되었다.

자식 클래스의 인스턴스를 생성할 때 부모 클래스의 인스턴스가 없어도 가능하다. 왜냐하면 JVM의 Method Area에 클래스 메타데이터가 저장되어 있고, 자식 클래스의 메타데이터에는 부모 클래스를 참조하는 정보가 있어서 해당 멤버들이 자식 클래스의 멤버가 되어 이를 기반으로 인스턴스를 생성한다.

> 메타데이터는 Method Area에 저장되며, 클래스가 로드될 때 이 정보가 해당 영역에 저장됩니다. 이 정보에는 클래스의 구조, 메서드, 상속 관계, 변수에 대한 정보 등이 포함되어 있습니다.
>
> 상속을 받은 경우, 자식 클래스의 메타데이터에는 부모 클래스의 정보도 함께 저장됩니다. 이로 인해 부모 클래스의 멤버 변수와 메서드도 자식 클래스의 인스턴스 생성 시 함께 로드되고, 해당 인스턴스에서 사용할 수 있게 됩니다.
>
> 정리하자면, 클래스의 메타데이터는 Method Area에 저장되며, 상속 관계가 있을 경우 자식 클래스의 메타데이터에 부모 클래스의 정보도 함께 저장됩니다. 이렇게 함으로써 JVM은 클래스 및 상속 관계에 대한 정보를 유지하고, 인스턴스 생성 및 사용 시에 이를 활용합니다.

## 합성(포함)

필드로 클래스의 인스턴스를 참조

🔽 `Car` 클래스는 `Engine` 을 상속하는게 아니라, 가져다 쓰고있다.

```java
class Car {
    Engine engine; // 필드로 Engine 클래스 변수를 갖는다(has)

    Car(Engine engine) {
        this.engine = engine; // 생성자 초기화 할때 클래스 필드의 값을 정하게 됨
    }

    void drive() {
        System.out.printf("%s엔진으로 드라이브~\n", engine.EngineType);
    }

    void breaks() {
        System.out.printf("%s엔진으로 브레이크~\n", engine.EngineType);
    }
}

class Engine {
    String EngineType; // 디젤, 가솔린, 전기

    Engine(String type) {
        EngineType = type;
    }
}

public class Main {
    public static void main(String[] args) {
        Car digelCar = new Car(new Engine("디젤"));
        digelCar.drive(); // 디젤엔진으로 드라이브~

        Car electroCar = new Car(new Engine("전기"));
        electroCar.drive(); // 전기엔진으로 드라이브~
    }
}
```

이 방식을 포워딩(forwarding) 이라고 한다.

## 상속 대신 합성을 이용하라

상속은 현업에서도 지양하는 편이며, 매우 제한적으로 사용한다. 왜냐하면 치명적인 단점이 있기 때문이다.

1. 결합도가 높아짐
2. 불필요한 기능도 상속됨
3. 부모 클래스에 문제가 있으면, 그대로 넘어감
4. 부모 클래스를 변경하면 자식 클래스도 추가해야됨
5. 메서드 오버라이딩의 오동작(부모 클래스의 메서드가 어떻게 동작하는지 자세히 모르고 맘대로 오버라이딩 해버리는 경우)
6. 불필요한 인터페이스 상속
7. 클래스 폭발(?)
   - 새로운 조합이 필요하면 조합의 수만큼 새로운 클래스를 추가해 상속하는 것 뿐이다.
8. 단일 상속의 한계



### 합성을 사용해야하는 이유

구현에 의존하지 않기 때문이다. 또한 ==런타임때 동적으로 합성 관계를 바꿀 수 있다.==



# 상속

```java
class Parent {
    int age;
    void saySomething() {
        System.out.println("부모 클래스");
    }
}

class Child extends Parent {
    int name;
    
    void saySomething() {
        System.out.println("자식 클래스");
    }
}
```



```java
Child c = new Parent(); // 불가능함. 에러
Child c = new Child();

Parent p = new Parent();
Parent p = new Child();
```

- `Child c = new Parent()` 는 불가능한 코드. 컴파일 에러

- `Parent p = new Child()` 는 **upcasting**의 경우이고, p는 Child 클래스의 메서드나 속성에 접근할 수 없음. 
- **downcasting**을 통해 Child의 속성, 메서드를 사용할 수 있음 `((Child)p).childClassMethod();`



## Q. upcasting이 필요한 경우?

> 다형성 => 같은 메서드 호출이지만 참조하는 객체의 타입에 따라 다른 동작을 수행할 수 있게 됩니다.

```java
Parent p1 = new Child1();
Parent p2 = new Child2();

p1.doSomething(); // Child1's doSomething()
p2.doSomething(); // Child2's doSomething()
```

Child1과 Child2 에서 `doSomething()` 을 다르게 구현했다면, 같은 메서드 호출이지만 객체의 실제 타입에 따라 다르게 동작함.



- `Child1 c1 = new Child1()` 랑 `Child2 c2 = new Child2()` 로 해도 되지 않는가?

- `Child1 c1 = new Child1();`와 `Child2 c2 = new Child2();`로 선언하게 되면, `c1`과 `c2`는 각각 `Child1`과 `Child2` 타입의 참조 변수가 됩니다. 이 경우 `c1`과 `c2`는 각각의 클래스에 선언된 모든 메서드와 속성에 접근할 수 있습니다.

  반면에 `Parent p1 = new Child1();`와 `Parent p2 = new Child2();`로 선언하게 되면, `p1`과 `p2`는 `Parent` 타입의 참조 변수가 되며, `Parent` 클래스에 선언된 메서드와 속성에만 접근할 수 있게 됩니다.

  그럼에도 불구하고 왜 후자를 선택할까요? **이는 다형성이라는 객체지향 프로그래밍의 핵심 원칙 때문입니다.** 이를 통해 코드를 더 유연하고 확장 가능하게 만들 수 있습니다. 예를 들어, 여러 하위 클래스가 같은 상위 클래스를 상속받고 있을 때, 상위 클래스 타입의 변수를 사용하면 하위 클래스의 구체적인 타입에 상관없이 코드를 작성할 수 있습니다.

  ```java
  Parent[] parents = new Parent[2];
  parents[0] = new Child1();
  parents[1] = new Child2();
  
  for (Parent p : parents) {
      p.doSomething(); // Child1과 Child2가 doSomething을 오버라이딩 했다면, 각 하위 클래스의 메서드가 실행됨
  }
  ```

  이런 식으로 작성된 코드는 `Child1`과 `Child2` 외에 새로운 하위 클래스가 추가되더라도 그대로 동작하며, 이는 코드의 유지 관리가 더 쉬워짐을 의미합니다. 따라서 상황에 따라 `Parent p = new Child();` 형태의 코드가 더 적합할 수 있습니다.



## Q. `@Override` 없이 오버라이딩?

> 필수는 아니지만 코드의 가독성과 오류를 방지하는데에 있어서 좋다.

Java에서는 부모 클래스의 메서드를 자식 클래스에서 재정의하거나 "오버라이드" 할 때, `@Override` 어노테이션을 사용하는 것이 권장되지만 **필수는 아닙니다.** 

`@Override` 어노테이션은 컴파일러에게 이 메서드가 부모 클래스의 메서드를 오버라이드하는 것임을 명시적으로 알려줍니다. 이를 통해 컴파일러는 실수로 메서드 시그니처를 잘못 입력하여 실제로는 오버라이드가 이루어지지 않았을 때, 그것을 오류로 잡아낼 수 있습니다. 따라서 `@Override` 어노테이션은 **프로그래머의 실수를 방지**하는 역할을 합니다.

예를 들어, 부모 클래스의 `doSomething()` 메서드를 오버라이드하려고 하지만 실수로 `doSometing()` (마지막 'h'가 빠짐)라고 썼다고 가정해봅시다. 이 경우 `@Override` 어노테이션을 사용하면 컴파일러는 `doSometing()` 메서드가 부모 클래스에 없다는 것을 알려주어 실수를 바로잡을 수 있게 합니다. 반면, `@Override` 어노테이션을 사용하지 않으면 컴파일러는 이를 새로운 메서드로 인식하고 아무런 오류를 띄우지 않습니다. 따라서 원하던 대로 코드가 동작하지 않을 수 있습니다.

```java
class Parent {
    void doSomething() {
        System.out.println("부모 클래스");
    }
}

class Child extends Parent {
    // 오타로 g가 빠졌는데 알 수 없음. 오버라이드가 아닌 그냥 새로운 함수
    void doSomethin() {
        System.out.println("자식 클래스");
    }
    
    // doSomething이 아니기 때문에 부모에 doSomethin 따윈 없다고 알려줌
    @Override
    void doSomethin() {
        System.out.println("자식 클래스");
    }
}
```

따라서 `@Override` 어노테이션을 사용하면 의도하지 않은 실수를 방지하고 코드의 가독성을 높이는 데 도움이 됩니다. 그럼에도 불구하고 `@Override`를 사용하지 않아도 컴파일과 실행 자체에는 문제가 없습니다. 오버라이드를 하는 메서드라는 것을 명확히 나타내고 싶지 않거나, 간혹 특정 상황에서 어노테이션을 생략하고자 할 때 `@Override`를 사용하지 않을 수 있습니다. 그러나 이는 일반적으로 권장되지 않는 방식입니다.



## 다중 상속이 왜 불가능한가

![img](https://t1.daumcdn.net/cfile/tistory/995652405C723D2216)

=> 다이아몬드 문제 발생

만약 FatherA와 FatherB에 같은 메서드가 존재한다면, Son은 어떤 부모의 메서드를 사용할지 알 수 없게된다.

인터페이스는 문제 없다. 인터페이스에서는 구현을 하지 않기 때문이다.

그러면 JDK8부터 생긴 default Method는?? => 직접 재정의



## `super`

> 자식 클래스에서 부모 클래스로부터 상속받은 멤버를 참조하는데 사용되는 참조변수

- 부모 클래스로부터 상속받은 멤버도 자식 클래스 자신의 멤버이므로 super 대신 this를 사용할 수 있다. 부모 클래스의 멤버와 중복이라 구분해야할 때 super를 사용하는게 좋다.
- static은 인스턴스와 관련이 없기 때문에 `this`, `super` 모두 사용할 수 없다.

#### `this()` , `super()`

- 둘 다 생성자이다. this는 같은 클래스의 다른 생성자를 호출한다. super는 부모 클래스의 생성자를 호출하는데 사용된다.
- 자식 클래스의 인스턴스는 자식 클래스와 부모 클래스의 멤버가 모두 합쳐진 하나의 인스턴스로 생성된다. 
  - 이때 조상 클래스 멤버의 초기화 작업이 필요하므로 자손 클래스의 생성자에서 **첫 줄에 조상 클래스의 생성자를 호출해야한다.**
  - Object까지 거슬러 올라가며 반복된다. Object를 제외한 모든 클래스의 생성자는 철줄에 반드시 자신의 다른 생성자 또는 조상의 생성자를 호출해야한다.
    - 아니라면 컴파일러는 생성자의 첫 줄에 `super()`를 자동으로 추가한다.
