# length VS size

Java에서, length() 메서드는 **배열의 크기**를 반환하는 데 사용되고, size() 메서드는 **컬렉션의 크기**를 반환하는 데 사용됩니다.

따라서, length()는 배열에서만 사용 가능하며, size()는 Collection 인터페이스를 구현하는 클래스(예: ArrayList, HashSet 등)에서 사용 가능합니다.

또한, length()는 배열의 인스턴스 변수이므로 배열의 길이가 변경되지 않는 한 항상 일정합니다. 반면, size()는 컬렉션의 내용에 따라 동적으로 변경될 수 있습니다.

따라서, 배열의 크기를 얻으려면 length()를 사용하고, 컬렉션의 크기를 얻으려면 size()를 사용하는 것이 좋습니다.



### String의 길이 => `length()`

`length()` 메서드는 `String` 클래스에 정의된 메서드입니다.  Java에서 `String` 클래스는 문자열을 나타내는 데 사용되며, `length()` 메서드를 사용하여 문자열의 길이를 알 수 있습니다.

```
javaCopy codeString str = "Hello, World!";
int length = str.length(); // 문자열의 길이를 구함
System.out.println(length); // 13이 출력됨
```

위 예제에서는 `String` 클래스의 `length()` 메서드를 호출하여 문자열의 길이를 구하고 있습니다. 이 메서드는 문자열의 길이를 반환합니다.

`String`의 `length()` 메서드는 유니코드 문자 수를 반환합니다. 즉, `String` 내의 모든 문자의 수를 반환합니다. 예를 들어, "Hello, World!" 문자열은 13개의 문자로 구성되어 있으므로, `length()` 메서드는 13을 반환합니다.



```java
private final int count; // String 객체가 생성될 때 문자열의 길이를 계산하여 초기화 됨

public int length() {
    return count;
}
```

이를 통해 `length()` 메서드가 호출될 때마다 문자열의 길이를 다시 계산할 필요가 없어 성능을 향상시킬 수 있습니다.



#### Java에서 String의 길이를 구할 때, String 클래스 내에 count 라는 변수가 있음에도 불구하고 length() 함수를 사용하는 이유는 무엇인가요?

Java에서 String의 길이를 구할 때 `length()` 함수를 사용하는 이유는 **캡슐화(encapsulation) 원칙** 때문입니다. 캡슐화는 객체 지향 프로그래밍의 핵심 원칙 중 하나로, **객체의 상태를 직접 변경하거나 접근하는 대신 메서드를 통해 간접적으로 수행하도록 하는 것입니다.**

`String` 클래스의 `count` 변수는 클래스 내부에서 문자열의 길이를 저장하는 용도로 사용됩니다. 그러나 이 변수는 `private`로 선언되어 외부에서 직접 접근할 수 없습니다. 이렇게 하는 이유는 문자열의 내부 표현이나 동작이 변경되더라도 사용자가 영향을 받지 않도록 하기 위해서입니다.

`length()` 함수는 이러한 캡슐화 원칙에 따라 외부에서 문자열의 길이를 가져올 수 있는 방법을 제공합니다. 이 함수를 사용하면 `String` 객체의 내부 상태에 안전하게 접근할 수 있으며, 클래스 구현이 변경되더라도 외부 코드에 영향을 주지 않습니다.

결론적으로, `length()` 함수를 사용하는 이유는 객체 지향 원칙인 캡슐화를 준수하고, 코드의 안정성과 유지 보수성을 높이기 위함입니다.



### String[]의 길이 => `length`

Java에서 배열은 객체입니다. 따라서 배열 객체는 `length`라는 인스턴스 변수를 가지고 있습니다. 이 변수는 배열의 길이를 나타냅니다.

배열의 길이를 얻으려면 `length` 변수에 접근하여 해당 값을 얻어내면 됩니다. 예를 들어, `String` 타입의 배열 `arr`이 있다면, `arr.length`를 사용하여 `arr`의 길이를 얻을 수 있습니다.

```
javaCopy codeString[] arr = {"apple", "banana", "cherry"};
int length = arr.length; // 배열의 길이를 구함
System.out.println(length); // 3이 출력됨
```

`length` 변수는 배열이 생성된 후에는 값이 변경되지 않으므로, `arr.length`는 항상 배열의 길이를 반환합니다. `length()` 메서드는 문자열의 길이를 반환하는 메서드입니다. `String[]` 배열은 `String` 타입의 객체 배열이므로, `String` 객체의 `length()` 메서드를 사용할 수 없습니다. 따라서 `length()` 메서드 대신 `length` 인스턴스 변수를 사용하여 `String[]` 배열의 길이를 얻어내는 것입니다.



#### 그렇다면 String[] 과 같은 배열은 왜 length라는 변수에 접근할 수 있나요? 

배열은 Java에서 기본 제공되는 기능이며, 객체 지향 원칙과 약간 다른 방식으로 작동합니다. 배열의 길이를 나타내는 `length` 변수는 배열의 내장 속성이며, 배열의 크기를 변경할 수 없기 때문에 배열의 길이를 가져올 때 직접 접근하는 것이 허용됩니다.

이는 배열이 내부 데이터에 대해 불변성을 갖기 때문에 캡슐화를 통한 데이터 보호를 엄격하게 적용할 필요가 없다고 볼 수 있습니다. 한 번 생성된 배열의 크기는 변경할 수 없으므로, `length` 변수에 직접 접근해도 객체의 상태에 위험을 초래하지 않습니다.

물론, Java에서는 배열 대신 `ArrayList`와 같은 컬렉션 클래스를 사용하면 캡슐화, 동적 크기 조절 등의 객체 지향 원칙을 따르는 코드를 작성할 수 있습니다. 이 경우, `size()` 메서드를 사용하여 컬렉션의 크기를 가져올 수 있습니다.

요약하자면, 배열의 `length` 변수에 직접 접근하는 것이 허용되는 이유는 배열이 내부 데이터에 대한 불변성을 가지고 있기 때문입니다. 하지만 객체 지향 원칙을 더 잘 따르고 싶다면 컬렉션 클래스를 사용하는 것을 고려해 보세요.



#### 그런데 String도 길이를 변할 수 없는건 마찬가지 아닌가요?

맞습니다. `String`은 불변 객체(immutable object)로 설계되어 있어 문자열의 길이와 내용이 변경되지 않습니다. 그러나 `String` 클래스는 객체 지향 원칙을 따르기 때문에, 일관성을 유지하고 클래스의 내부 구현에 대한 추상화를 제공하기 위해 `length()` 메서드를 사용합니다.

`String`의 불변성과 배열의 `length` 변수에 직접 접근하는 것 사이에는 논리적인 연결이 있지만, 이 두 가지 경우는 서로 다른 설계 원칙에 기반합니다. **배열은 Java의 기본 기능이며, 객체 지향 설계 원칙을 완전히 따르지 않습니다. 이에 반해, `String` 클래스는 객체 지향 원칙을 따르고 캡슐화를 통해 클래스의 내부 구현을 숨깁니다.**

불변성이 있는 객체의 속성에 대한 접근 방식은 해당 객체의 설계 원칙에 따라 다를 수 있습니다. 배열과 `String`은 둘 다 불변성을 갖지만, 배열은 기본 제공되는 기능이고 `String`은 객체 지향 설계 원칙을 따르는 클래스이기 때문에 길이 접근 방식이 다릅니다.



#### 그럼 왜 배열은 객체지향의 원리에 따라 만들지 않았나요?

배열이 객체 지향 원칙을 완전히 따르지 않은 이유는 배열이 Java 언어의 기본 기능 중 하나로, 효율성과 성능에 중점을 둔 설계를 가지기 때문입니다.

1. **효율성과 성능**: 배열은 연속적인 메모리 공간에 저장되어 있어, 인덱스를 통한 원소 접근이 매우 빠릅니다. 배열의 `length` 변수에 직접 접근하는 것도 이러한 성능상의 이점 때문입니다. 객체 지향 원칙을 완전히 따르면 추가적인 메서드 호출이 발생하고, 이로 인해 약간의 성능 저하가 발생할 수 있습니다.
2. **단순성**: 배열은 간단한 데이터 구조로서, 고정된 크기와 함께 사용하기 쉽고 명확한 구조를 제공합니다. 객체 지향 원칙을 적용하면 더 복잡한 설계가 필요하며, 간단한 경우에는 불필요한 추상화가 발생할 수 있습니다.
3. **하위 호환성**: Java는 C와 C++와 같은 이전 프로그래밍 언어에서 영향을 받았습니다. 이러한 언어에서 배열은 객체 지향 원칙을 따르지 않는 기본 데이터 구조로 사용되었습니다. Java는 이러한 언어와의 호환성을 유지하려고 하므로, 배열은 기본 제공되는 기능으로서 객체 지향 원칙을 완전히 따르지 않습니다.

하지만, Java에서는 객체 지향 원칙을 더 잘 따르는 데이터 구조를 제공하는 컬렉션 프레임워크가 있습니다. 이 프레임워크에서는 `ArrayList`와 같은 동적 배열과 다양한 컬렉션 클래스를 제공하며, 캡슐화, 상속, 다형성 등의 객체 지향 원칙을 따릅니다. 이러한 컬렉션 클래스를 사용하면 객체 지향 원칙을 따르는 동시에 유연하고 확장 가능한 코드를 작성할 수 있습니다.



