# 네트워크 어플리케이션의 원리

네트워크는 여러 레이어로 구분할 수 있지만, 우선 가장 익숙하고 쉬운 어플리케이션 레이어 부터 시작해봅시다!

어플리케이션의 종류는 셀 수 없지 많지만, 그 중 HTTP에 대해 얘기를 할거에요. (아직 라우터는 나중에...)

어떻게 다른 기계의 프로그램끼리 메세지를 주고받을 수 있는걸까? ==소켓==

- 소켓 : 
  - 운영체제가 제공하는 시스템 콜의 일부.. 네트워크 기능을 쓸 수 있게 해주는 API
  - IP 주소 + 포트 번호 로 구성되어있어서 정확히 찾아갈 수 있도록 함
  - 서버는 IP, 포트 번호를 고정시켜 놓는다. 고정되어야 찾아올 수 있으니까

전송 계층이 제공해줬으면 하는 서비스(보안, 속도..)가 있다. 하지만 현실은 신뢰성 외에는 아무런 기능도 제공하지 않는다.

TCP 는 최소한 내가 보내는게 유실되지 않고(reliable) 전송된다.

프로토콜 이름만 이해해도 반은 먹고 간다.

HyperText ? -> 링크 있는거 + Transfer Protocol

HTTP는 하위 계층(전송)의 서비스를 받는데,  TCP를 활용한다. HTTP 만드는 사람이 정했다.

HTTP 메세지들은 중간에 유실되지 않고 신뢰성 있게 서버와 통신이 가능하다~ 대신 비용(UDP보다 비싸게 네트워크 리소스에 대한)을 내야한다.

- TCP로 통신하려면 TCP connection이 맺어져야한다.
- HTTP는 `Stateless` 하다. Request와 Response이후 서버는 클라이언트에 대해 어떠한 것도 기억하지 않는다.

RTT : Round Trip Time -> 클라이언트에서 서버까지 패킷이 갔다가 돌아오는데 걸리는 시간

Proxy Server의 장점

- 사용자는 빠른 응답을 받을 수 있다.
- 서버의 부담이 덜하다
- 트래픽 감소로 비용 절감



# DNS: Domain Name System

캐시가 있으면 무조건 빨라지는게 맞지만, 원본 데이터와 일치시키기 위한 정책이 필요하다.

access link utilization이 80% 넘어가기 시작하면 지연이 발생한다.

해결방법

1. 케이블 추가 설치 : 비용이 많이 발생함
2. web proxy 설치(local web cache)
   - proxy 서버에 일단 무조건 먼저 요청해봄
   - hit ratio : 0.4 (요청의 40%는 캐시가 갖고 있다.)

웹 캐시 만으로도 응답 속도를 훨씬 개선시킬 수 있다.

### Conditional GET

HTTP 요청 메세지가 시작이 GET 과 같이 메서드로 시작하는데, 메세지에 `if-modified-since: <date>` 를 확인하고 바뀌지 않았다면 `304 Not Modified`를 보내면서 실제 파일을 보내지 않음

(proxy 서버가 일반 서버에 데이터가 언제 마지막으로 수정되었는지만 확인하는 요청을 보내는 것이다. 바뀌지 않았다면 실제 데이터를 서버에서 다시 가져오지 않아도 되니까)

GET이긴 하지만, 조건에 따라서 메세지를 받겠다. proxy에서 일관성 문제를 해결하는데 어느정도 해결책이 될 수 있다.

## DNS

다른 머신끼리 프로세스로 통신하려면 `IP 주소 + 포트번호` 가 필요하다. 그리고 서버의 포트번호는 정해져있다.

이때 사용자가 IP주소를 외우기는 쉽지 않다. 이런 IP 주소에 해당하는 host name을 저장해두면 사용자가 편하잖아. 

그런데 DNS에 저장될 데이터의 양은 거의 무제한이고, 한 군데에서만 관리하면 속도 저하 및 SPOF 문제가 발생한다.

규모가 커지면 -> 분산화 / 계층화 가 필요하다.

Root -> (Top Level) .com / .org / .net  -> ... (Authoritative) 각 제공자가 관리를 해야한다.

ex) google이 관리하는 네트워크에서 name - ip 정보를 관리하고 제공해야한다.

### Local DNS name server

우선 로컬에 있는 네임 서버에다가 name의 ip 주소를 물어보는걸 먼저 하는데, 그 때 사용되는 서버 (ISP 가 가진 서버?) cache Hit이 꽤 높겠죠

- iterated Query : 내가 정보는 모르지만, 이 정보를 아는 다른 DNS 서버에 대신 쿼리를 보내줄게
- DNS 에 저장된 정보의 컬럼은 (name, value, type, ttl) 이다.
  - TTL : Time to Live, 이 레코드가 유효한 기간을 설정해둔다. 정해진 시간이 지나면 새로 요청해서 name과 ip 정보를 가져와야한다.
  - type : A, NS, CNAME, MX
    - A type : name은 hostname,value는 IP 주소
    - NS(Name Server) type : name은 도메인(.com), value는 authoritative 네임 서버의 hostname

`dns.edu` 에 접근하려고 한다.

root -> .edu -> dns.edu

| name    | value   | type | TTL  |
| ------- | ------- | ---- | ---- |
| .edu    | dns.edu | NS   |      |
| dns.edu | 5.5.5.5 | A    |      |

-> dns.edu에 저장된 모든 레코드의 타입은 A type이겠쥬?

### DNS가 UDP를 쓰는 이유

DNS를 어플리케이션 계층에서 계속 얘기를 하고 있었다. HTTP 요청을 하기 전에, 주소를 모르니까 DNS라는 준비 동작을 하는거다.

DNS, HTTP 둘 다 어플리케이션 레이어다. 그럼 DNS는 하위 계층의 어떤 서비스를 사용할까? DNS는 UDP 기반으로 가져온다.

왜 그럴까?? 

DNS가 주고받는 데이터의 크기가 매우 작다. 유실 될 확률도 매우 낮고, 유실 되어도 큰 문제가 없다. 그냥 다시 갔다오면 된다.

3 way handshake가 필요 없기 때문에 빠르다

